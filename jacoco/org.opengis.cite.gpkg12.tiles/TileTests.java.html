<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TileTests.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoPackage 1.2 Conformance Test Suite</a> &gt; <a href="index.source.html" class="el_package">org.opengis.cite.gpkg12.tiles</a> &gt; <span class="el_source">TileTests.java</span></div><h1>TileTests.java</h1><pre class="source lang-java linenums">package org.opengis.cite.gpkg12.tiles;

import static org.testng.Assert.assertTrue;
import static org.testng.AssertJUnit.fail;

import java.io.IOException;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Map;
import java.util.stream.Collectors;

import org.opengis.cite.gpkg12.ColumnDefinition;
import org.opengis.cite.gpkg12.ErrorMessage;
import org.opengis.cite.gpkg12.ErrorMessageKeys;
import org.opengis.cite.gpkg12.ForeignKeyDefinition;
import org.opengis.cite.gpkg12.TableVerifier;
import org.opengis.cite.gpkg12.TileFixture;
import org.opengis.cite.gpkg12.UniqueDefinition;
import org.opengis.cite.gpkg12.util.DatabaseUtility;
import org.testng.annotations.Test;

/**
 * Defines test methods that apply to descriptive information about a
 * GeoPackage's content as it pertains to tiles.
 *
 * &lt;p style=&quot;margin-bottom: 0.5em&quot;&gt;
 * &lt;strong&gt;Sources&lt;/strong&gt;
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;&lt;a href=&quot;http://www.geopackage.org/spec/#tiles&quot; target= &quot;_blank&quot;&gt;
 * GeoPackage Encoding Standard - 2.2. Tiles&lt;/a&gt; (OGC 12-128r12)&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * @author Luke Lambert, Jeff Yutzler
 */
<span class="fc" id="L45">public class TileTests extends TileFixture</span>
{
	/**
	 * In a GeoPackage that contains a tile pyramid user data table that
	 * contains tile data, by default, zoom level pixel sizes for that table
	 * SHALL vary by a factor of 2 between adjacent zoom levels in the tile
	 * matrix metadata table.
	 *
	 * @see &lt;a href=&quot;http://www.geopackage.org/spec/#_requirement-35&quot; target=
	 *      &quot;_blank&quot;&gt;Zoom Times Two - Requirement 35&lt;/a&gt;
	 *
	 * @throws SQLException
	 *             If an SQL query causes an error
	 */
	@Test(description = &quot;See OGC 12-128r12: Requirement 35&quot;)
	public void zoomTimesTwo() throws SQLException
	{
<span class="fc bfc" id="L62" title="All 2 branches covered.">		for(final String tableName : this.tileTableNames)</span>
		{
<span class="pc" id="L64">			try(final PreparedStatement preparedStatement = this.databaseConnection.prepareStatement(&quot;SELECT table_name, zoom_level, pixel_x_size, pixel_y_size, matrix_width, matrix_height, tile_width, tile_height FROM gpkg_tile_matrix WHERE table_name = ? ORDER BY zoom_level ASC;&quot;))</span>
			{
<span class="fc" id="L66">				preparedStatement.setString(1, tableName);</span>

<span class="pc" id="L68">				try(final ResultSet resultSet = preparedStatement.executeQuery())</span>
				{
<span class="fc" id="L70">					int    lastZoomLevel  = Integer.MIN_VALUE;</span>
<span class="fc" id="L71">					double lastPixelXSize = 0.0;</span>
<span class="fc" id="L72">					double lastPixelYSize = 0.0;</span>

<span class="fc bfc" id="L74" title="All 2 branches covered.">					while(resultSet.next())</span>
					{
<span class="fc" id="L76">						final int    zoomLevel  = resultSet.getInt   (&quot;zoom_level&quot;);</span>
<span class="fc" id="L77">						final double pixelXSize = resultSet.getDouble(&quot;pixel_x_size&quot;);</span>
<span class="fc" id="L78">						final double pixelYSize = resultSet.getDouble(&quot;pixel_y_size&quot;);</span>

<span class="fc bfc" id="L80" title="All 2 branches covered.">						if(zoomLevel == lastZoomLevel + 1)</span>
						{
							//noinspection MagicNumber
<span class="pc bpc" id="L83" title="1 of 2 branches missed.">							assertTrue(isEqual((lastPixelXSize / 2.0), pixelXSize) &amp;&amp;</span>
<span class="pc bpc" id="L84" title="1 of 2 branches missed.">									isEqual((lastPixelYSize / 2.0), pixelYSize),</span>
<span class="fc" id="L85">									ErrorMessage.format(ErrorMessageKeys.VALUES_DO_NOT_VARY_BY_FACTOR_OF_TWO,</span>
<span class="fc" id="L86">											lastZoomLevel,</span>
<span class="fc" id="L87">											zoomLevel));</span>
						}

<span class="fc" id="L90">						lastZoomLevel  = zoomLevel;</span>
<span class="fc" id="L91">						lastPixelXSize = pixelXSize;</span>
<span class="fc" id="L92">						lastPixelYSize = pixelYSize;</span>
<span class="fc" id="L93">					}</span>
<span class="pc bpc" id="L94" title="6 of 8 branches missed.">				}</span>
<span class="pc bpc" id="L95" title="6 of 8 branches missed.">			}</span>
<span class="fc" id="L96">		}</span>
<span class="fc" id="L97">	}</span>

	/**
	 * In a GeoPackage that contains a tile pyramid user data table that
	 * contains tile data that is not &lt;a
	 * href=&quot;http://www.ietf.org/rfc/rfc2046.txt&quot;&gt;MIME type&lt;/a&gt;
	 * &lt;a href=&quot;http://www.jpeg.org/public/jfif.pdf&quot;&gt;image/jpeg&lt;/a&gt;, by default
	 * SHALL store that tile data in &lt;a
	 * href=&quot;http://www.iana.org/assignments/media-types/index.html&quot;&gt; MIME type
	 * &lt;/a&gt; &lt;a href=&quot;http://libpng.org/pub/png/&quot;&gt;image/png&lt;/a&gt;.
	 *
	 * @see &lt;a href=&quot;http://www.geopackage.org/spec/#_requirement-36&quot; target=
	 *      &quot;_blank&quot;&gt;MIME Type PNG - Requirement 36&lt;/a&gt;
	 *
	 * @throws SQLException
	 *             If an SQL query causes an error
	 * @throws IOException
	 *             If the bytes of an image cause an error when read
	 */
	@Test(description = &quot;See OGC 12-128r12: Requirement 36&quot;)
	public void imageFormat() throws SQLException, IOException
	{
<span class="fc bfc" id="L119" title="All 2 branches covered.">		for(final String tableName : this.tileTableNames)</span>
		{
<span class="pc" id="L121">			try(final Statement statement = this.databaseConnection.createStatement();</span>
<span class="fc" id="L122">					final ResultSet resultSet = statement.executeQuery(String.format(&quot;SELECT tile_data, id FROM '%s';&quot;, tableName)))</span>
			{
<span class="fc" id="L124">				final Collection&lt;Integer&gt; failedTileIds = new LinkedList&lt;&gt;();</span>

<span class="fc bfc" id="L126" title="All 2 branches covered.">				while(resultSet.next())</span>
				{
<span class="fc" id="L128">					final byte[] tileData = resultSet.getBytes(&quot;tile_data&quot;);</span>

<span class="pc bpc" id="L130" title="1 of 2 branches missed.">					if(!isAcceptedImageFormat(tileData))</span>
					{
<span class="nc" id="L132">						failedTileIds.add(resultSet.getInt(&quot;id&quot;));</span>
					}
<span class="fc" id="L134">				}</span>

				// TODO If this assert fails, subsequent tables won't be tested or reported
<span class="fc" id="L137">				assertTrue(failedTileIds.isEmpty(),</span>
<span class="fc" id="L138">						ErrorMessage.format(ErrorMessageKeys.INVALID_IMAGE_FORMAT,</span>
								tableName,
<span class="fc" id="L140">								failedTileIds.stream()</span>
<span class="fc" id="L141">								.map(Object::toString)</span>
<span class="fc" id="L142">								.collect(Collectors.joining(&quot;, &quot;))));</span>
<span class="pc bpc" id="L143" title="12 of 16 branches missed.">			}</span>
<span class="fc" id="L144">		}</span>
<span class="fc" id="L145">	}</span>

	/**
	 * In a GeoPackage that contains a tile pyramid user data table that
	 * contains tile data that is not &lt;a
	 * href=&quot;http://www.iana.org/assignments/media-types/index.html&quot;&gt;MIME type
	 * &lt;/a&gt; &lt;a href=&quot;http://libpng.org/pub/png/&quot;&gt;image/png&lt;/a&gt;, by default
	 * SHALL store that tile data in &lt;a
	 * href=&quot;http://www.ietf.org/rfc/rfc2046.txt&quot;&gt;MIME type&lt;/a&gt; &lt;a
	 * href=&quot;http://www.jpeg.org/public/jfif.pdf&quot;&gt;image/jpeg&lt;/a&gt;.
	 *
	 * @see &lt;a href=&quot;http://www.geopackage.org/spec/#_requirement-37&quot; target=
	 *      &quot;_blank&quot;&gt;MIME Type JPEG - Requirement 37&lt;/a&gt;
	 */
	@Test(description = &quot;See OGC 12-128r12: Requirement 37&quot;)
	public void imageFormatJpg()
	{
		// Ignore - this is covered by requirement 36. It doesn't make sense to
		// ask each tile &quot;Are you a PNG? If not, are you a JPG?&quot; *and* &quot;Are you
		// a JPG? If not, are you a PNG?&quot;
<span class="fc" id="L165">	}</span>

	/**
	 * A GeoPackage that contains a tile pyramid user data table SHALL contain
	 * {@code gpkg_tile_matrix_set} table or view per &lt;a href=
	 * &quot;http://www.geopackage.org/spec/#tile_matrix_set_data_table_definition&quot;&gt;
	 * Table Definition&lt;/a&gt;, &lt;a href=
	 * &quot;http://www.geopackage.org/spec/#gpkg_tile_matrix_set_cols&quot;&gt;Tile
	 * Matrix Set Table or View Definition&lt;/a&gt; and &lt;a
	 * href=&quot;http://www.geopackage.org/spec/#gpkg_tile_matrix_set_sql&quot;&gt;
	 * gpkg_tile_matrix_set Table Creation SQL&lt;/a&gt;.
	 *
	 * @see &lt;a href=&quot;http://www.geopackage.org/spec/#_requirement-38&quot; target=
	 *      &quot;_blank&quot;&gt;Tile Matrix Set - Table Definition - Requirement 38&lt;/a&gt;
	 *
	 * @throws SQLException
	 *             If an SQL query causes an error
	 */
	@Test(description = &quot;See OGC 12-128r12: Requirement 38&quot;)
	public void tileMatrixSetTable() throws SQLException
	{
<span class="fc" id="L186">		final String tableName = &quot;gpkg_tile_matrix_set&quot;;</span>

<span class="fc" id="L188">		assertTrue(DatabaseUtility.doesTableOrViewExist(this.databaseConnection, tableName), </span>
<span class="fc" id="L189">				ErrorMessage.format(ErrorMessageKeys.MISSING_TABLE, tableName));</span>

		try
		{
<span class="fc" id="L193">			final Map&lt;String, ColumnDefinition&gt; tileMatrixSetColumns = new HashMap&lt;&gt;();</span>

<span class="fc" id="L195">			tileMatrixSetColumns.put(&quot;table_name&quot;, new ColumnDefinition(&quot;TEXT&quot;,    true, true,  true,  null));</span>
<span class="fc" id="L196">			tileMatrixSetColumns.put(&quot;srs_id&quot;,     new ColumnDefinition(&quot;INTEGER&quot;, true, false, false, null));</span>
<span class="fc" id="L197">			tileMatrixSetColumns.put(&quot;min_x&quot;,      new ColumnDefinition(&quot;DOUBLE&quot;,  true, false, false, null));</span>
<span class="fc" id="L198">			tileMatrixSetColumns.put(&quot;min_y&quot;,      new ColumnDefinition(&quot;DOUBLE&quot;,  true, false, false, null));</span>
<span class="fc" id="L199">			tileMatrixSetColumns.put(&quot;max_x&quot;,      new ColumnDefinition(&quot;DOUBLE&quot;,  true, false, false, null));</span>
<span class="fc" id="L200">			tileMatrixSetColumns.put(&quot;max_y&quot;,      new ColumnDefinition(&quot;DOUBLE&quot;,  true, false, false, null));</span>

<span class="fc" id="L202">			TableVerifier.verifyTable(this.databaseConnection,</span>
					tableName,
					tileMatrixSetColumns,
<span class="fc" id="L205">					new HashSet&lt;&gt;(Arrays.asList(new ForeignKeyDefinition(&quot;gpkg_spatial_ref_sys&quot;, &quot;srs_id&quot;,     &quot;srs_id&quot;),</span>
							new ForeignKeyDefinition(&quot;gpkg_contents&quot;,        &quot;table_name&quot;, &quot;table_name&quot;))),
<span class="fc" id="L207">					Collections.emptyList());</span>
		}
<span class="nc" id="L209">		catch(final Throwable th)</span>
		{
<span class="nc" id="L211">			fail(ErrorMessage.format(ErrorMessageKeys.BAD_TILE_MATRIX_SET_TABLE_DEFINITION, th.getMessage()));</span>
<span class="fc" id="L212">		}</span>
<span class="fc" id="L213">	}</span>

	/**
	 * Values of the {@code gpkg_tile_matrix_set} {@code table_name} column
	 * SHALL reference values in the gpkg_contents table_name column for rows
	 * with a data type of &quot;tiles&quot;.
	 *
	 * @see &lt;a href=&quot;http://www.geopackage.org/spec/#_requirement-39&quot; target=
	 *      &quot;_blank&quot;&gt;Table Data Values - Requirement 39&lt;/a&gt;
	 *
	 * @throws SQLException
	 *             If an SQL query causes an error
	 */
	@Test(description = &quot;See OGC 12-128r12: Requirement 39&quot;)
	public void matrixSetNamesReferenceTiles() throws SQLException
	{
<span class="fc bfc" id="L229" title="All 2 branches covered.">		for (final String tableName : this.tileTableNames) {</span>
<span class="pc" id="L230">			try (</span>
<span class="fc" id="L231">					final Statement statement1 = this.databaseConnection.createStatement();</span>
<span class="fc" id="L232">					final ResultSet resultSet1 = statement1.executeQuery(String.format(&quot;SELECT table_name FROM gpkg_tile_matrix_set WHERE table_name = '%s'&quot;, tableName));</span>
					) {
<span class="fc" id="L234">				assertTrue(resultSet1.next(),</span>
<span class="fc" id="L235">						ErrorMessage.format(ErrorMessageKeys.UNREFERENCED_TILE_MATRIX_SET_TABLE, tableName));				</span>
<span class="pc bpc" id="L236" title="12 of 16 branches missed.">			}</span>
<span class="fc" id="L237">		}</span>
<span class="fc" id="L238">	}</span>

	/**
	 * The {@code gpkg_tile_matrix_set} table or view SHALL contain one row
	 * record for each tile pyramid user data table.
	 *
	 * @see &lt;a href=&quot;http://www.geopackage.org/spec/#_requirement-40&quot; target=
	 *      &quot;_blank&quot;&gt;Table Data Values - Requirement 40&lt;/a&gt;
	 *
	 * @throws SQLException
	 *             If an SQL query causes an error
	 */
	@Test(description = &quot;See OGC 12-128r12: Requirement 40&quot;)
	public void matrixSetNameForEachTilesTable() throws SQLException
	{
<span class="pc" id="L253">		try(Statement statement = this.databaseConnection.createStatement();</span>
<span class="fc" id="L254">				ResultSet resultSet = statement.executeQuery(&quot;SELECT table_name FROM gpkg_tile_matrix_set;&quot;))</span>
		{
<span class="fc" id="L256">			final Collection&lt;String&gt; tableNames = new LinkedList&lt;&gt;();</span>

<span class="fc bfc" id="L258" title="All 2 branches covered.">			while(resultSet.next())</span>
			{
<span class="fc" id="L260">				tableNames.add(resultSet.getString(&quot;table_name&quot;));</span>
			}

<span class="fc bfc" id="L263" title="All 2 branches covered.">			for(final String tableName : this.tileTableNames)</span>
			{
<span class="fc" id="L265">				assertTrue(tableNames.contains(tableName),</span>
<span class="fc" id="L266">						ErrorMessage.format(ErrorMessageKeys.UNREFERENCED_TILES_CONTENT_TABLE_NAME, tableName));</span>
<span class="fc" id="L267">			}</span>
<span class="pc bpc" id="L268" title="12 of 16 branches missed.">		}</span>
<span class="fc" id="L269">	}</span>

	/**
	 * Values of the {@code gpkg_tile_matrix_set} {@code srs_id} column SHALL
	 * reference values in the {@code gpkg_spatial_ref_sys} {@code srs_id}
	 *
	 * @see &lt;a href=&quot;http://www.geopackage.org/spec/#_requirement-41&quot; target=
	 *      &quot;_blank&quot;&gt;Table Data Values - Requirement 41&lt;/a&gt;
	 *
	 * @throws SQLException
	 *             If an SQL query causes an error
	 */
	@Test(description = &quot;See OGC 12-128r12: Requirement 41&quot;)
	public void matrixSetSrsIdReferencesGoodId() throws SQLException
	{
<span class="pc" id="L284">		try(final Statement statement = this.databaseConnection.createStatement();</span>
<span class="fc" id="L285">				final ResultSet resultSet = statement.executeQuery(&quot;SELECT srs_id from gpkg_tile_matrix_set WHERE srs_id NOT IN (SELECT srs_id FROM gpkg_spatial_ref_sys);&quot;))</span>
		{
<span class="pc bpc" id="L287" title="1 of 2 branches missed.">			if(resultSet.next())</span>
			{
<span class="nc" id="L289">				fail(ErrorMessage.format(ErrorMessageKeys.BAD_MATRIX_SET_SRS_REFERENCE, resultSet.getInt(&quot;srs_id&quot;)));</span>
			}
<span class="pc bpc" id="L291" title="12 of 16 branches missed.">		}</span>
<span class="fc" id="L292">	}</span>

	/**
	 * Test case
	 * {@code /opt/tiles/gpkg_tile_matrix_set/data/data_values_srs_id_match}
	 *
	 * @see &lt;a href=&quot;_requirement-147&quot; target= &quot;_blank&quot;&gt;Tile Matrix Set SRS ID
	 *      Column - Requirement 147&lt;/a&gt;
	 *
	 * @throws SQLException
	 *             If an SQL query causes an error
	 */
	@Test(description = &quot;See OGC 12-128r15: Requirement 147&quot;)
	public void featureGeometryColumnsDataValuesSrsId() throws SQLException {
<span class="pc" id="L306">		try (</span>
			// 1
<span class="fc" id="L308">			final Statement statement = this.databaseConnection.createStatement();</span>

<span class="fc" id="L310">			final ResultSet resultSet = statement.executeQuery(&quot;SELECT a.srs_id srs_id, a.table_name tn FROM gpkg_tile_matrix_set a, gpkg_contents b WHERE a.table_name = b.table_name and a.srs_id != b.srs_id&quot;);</span>
		) {
			// 2
<span class="pc bpc" id="L313" title="1 of 2 branches missed.">			if (resultSet.next()){</span>
<span class="nc" id="L314">				fail(ErrorMessage.format(ErrorMessageKeys.SRS_MISMATCH, &quot;gpkg_tile_matrix_set&quot;, resultSet.getInt(&quot;srs_id&quot;), resultSet.getString(&quot;tn&quot;)));</span>
			}
<span class="pc bpc" id="L316" title="12 of 16 branches missed.">		}</span>
<span class="fc" id="L317">	}</span>

	/**
	 * A GeoPackage that contains a tile pyramid user data table SHALL contain
	 * a {@code gpkg_tile_matrix} table or view per clause 2.2.7.1.1 &lt;a href=
	 * &quot;http://www.geopackage.org/spec/#tile_matrix_data_table_definition&quot;&gt;
	 * Table Definition&lt;/a&gt;, Table &lt;a href=
	 * &quot;http://www.geopackage.org/spec/#gpkg_tile_matrix_cols&quot;&gt;Tile Matrix
	 * Metadata Table or View Definition&lt;/a&gt; and Table &lt;a href=
	 * &quot;http://www.geopackage.org/spec/#gpkg_tile_matrix_sql&quot;&gt;
	 * gpkg_tile_matrix Table Creation SQL&lt;/a&gt;.
	 *
	 * @see &lt;a href=&quot;http://www.geopackage.org/spec/#_requirement-42&quot; target=
	 *      &quot;_blank&quot;&gt;Tile Matrix - Table Definition - Requirement 42&lt;/a&gt;
	 *
	 * @throws SQLException
	 *             If an SQL query causes an error
	 */
	@Test(description = &quot;See OGC 12-128r12: Requirement 42&quot;)
	public void tileMatrixTableDefinition() throws SQLException
	{
<span class="fc" id="L338">		final String tableName = &quot;gpkg_tile_matrix&quot;;</span>

<span class="fc" id="L340">		assertTrue(DatabaseUtility.doesTableOrViewExist(this.databaseConnection, tableName), </span>
<span class="fc" id="L341">				ErrorMessage.format(ErrorMessageKeys.MISSING_TABLE, tableName));</span>

		try
		{
<span class="fc" id="L345">			final Map&lt;String, ColumnDefinition&gt; tileMatrixColumns = new HashMap&lt;&gt;();</span>

<span class="fc" id="L347">			tileMatrixColumns.put(&quot;table_name&quot;,     new ColumnDefinition(&quot;TEXT&quot;,    true, true,  true,  null));</span>
<span class="fc" id="L348">			tileMatrixColumns.put(&quot;zoom_level&quot;,     new ColumnDefinition(&quot;INTEGER&quot;, true, true,  true,  null));</span>
<span class="fc" id="L349">			tileMatrixColumns.put(&quot;matrix_width&quot;,   new ColumnDefinition(&quot;INTEGER&quot;, true, false, false, null));</span>
<span class="fc" id="L350">			tileMatrixColumns.put(&quot;matrix_height&quot;,  new ColumnDefinition(&quot;INTEGER&quot;, true, false, false, null));</span>
<span class="fc" id="L351">			tileMatrixColumns.put(&quot;tile_width&quot;,     new ColumnDefinition(&quot;INTEGER&quot;, true, false, false, null));</span>
<span class="fc" id="L352">			tileMatrixColumns.put(&quot;tile_height&quot;,    new ColumnDefinition(&quot;INTEGER&quot;, true, false, false, null));</span>
<span class="fc" id="L353">			tileMatrixColumns.put(&quot;pixel_x_size&quot;,   new ColumnDefinition(&quot;DOUBLE&quot;,  true, false, false, null));</span>
<span class="fc" id="L354">			tileMatrixColumns.put(&quot;pixel_y_size&quot;,   new ColumnDefinition(&quot;DOUBLE&quot;,  true, false, false, null));</span>

<span class="fc" id="L356">			TableVerifier.verifyTable(this.databaseConnection,</span>
					tableName,
					tileMatrixColumns,
<span class="fc" id="L359">					new HashSet&lt;&gt;(Arrays.asList(new ForeignKeyDefinition(&quot;gpkg_contents&quot;, &quot;table_name&quot;, &quot;table_name&quot;))),</span>
<span class="fc" id="L360">					Collections.emptyList());</span>
		}
<span class="nc" id="L362">		catch(final Throwable th)</span>
		{
<span class="nc" id="L364">			fail(ErrorMessage.format(ErrorMessageKeys.BAD_TILE_MATRIX_TABLE_DEFINITION, th.getMessage()));</span>
<span class="fc" id="L365">		}</span>
<span class="fc" id="L366">	}</span>

	/**
	 * Values of the {@code gpkg_tile_matrix} {@code table_name}
	 * column SHALL reference values in the {@code gpkg_contents} {@code
	 * table_name} column for rows with a {@code data_type} of
	 * 'tiles'.
	 *
	 * @see &lt;a href=&quot;http://www.geopackage.org/spec/#_requirement-43&quot; target=
	 *      &quot;_blank&quot;&gt;Tile Matrix - Table Data Values - Requirement 43&lt;/a&gt;
	 *
	 * @throws SQLException
	 *             If an SQL query causes an error
	 */
	@Test(description = &quot;See OGC 12-128r12: Requirement 43&quot;)
	public void tileMatrixTableContentsReferences() throws SQLException
	{
<span class="pc" id="L383">		try(final Statement statement = this.databaseConnection.createStatement();</span>
<span class="fc" id="L384">				final ResultSet resultSet = statement.executeQuery(&quot;SELECT table_name FROM gpkg_tile_matrix AS tm WHERE table_name NOT IN (SELECT table_name FROM gpkg_contents AS gc WHERE tm.table_name = gc.table_name);&quot;))</span>
		{
<span class="fc" id="L386">			final Collection&lt;String&gt; unreferencedTables = new LinkedList&lt;&gt;();</span>

<span class="pc bpc" id="L388" title="1 of 2 branches missed.">			while(resultSet.next())</span>
			{
<span class="nc" id="L390">				unreferencedTables.add(resultSet.getString(&quot;table_name&quot;));</span>
			}

<span class="fc" id="L393">			assertTrue(unreferencedTables.isEmpty(),</span>
<span class="fc" id="L394">					ErrorMessage.format(ErrorMessageKeys.BAD_MATRIX_CONTENTS_REFERENCES,</span>
<span class="fc" id="L395">							String.join(&quot;, &quot;, unreferencedTables)));</span>
<span class="pc bpc" id="L396" title="12 of 16 branches missed.">		}</span>
<span class="fc" id="L397">	}</span>

	/**
	 * The {@code gpkg_tile_matrix} table or view SHALL contain one row
	 * record for each zoom level that contains one or more tiles in each tile
	 * pyramid user data table or view.
	 *
	 * @see &lt;a href=&quot;http://www.geopackage.org/spec/#_requirement-44&quot; target=
	 *      &quot;_blank&quot;&gt;Tile Matrix - Table Data Values - Requirement 44&lt;/a&gt;
	 *
	 * @throws SQLException
	 *             If an SQL query causes an error
	 */
	@Test(description = &quot;See OGC 12-128r12: Requirement 44&quot;)
	public void tileMatrixPerZoomLevel() throws SQLException
	{
<span class="fc bfc" id="L413" title="All 2 branches covered.">		for(final String tableName : this.tileTableNames)</span>
		{
<span class="fc" id="L415">			final Collection&lt;Integer&gt; tileMatrixZooms = new LinkedList&lt;&gt;();</span>

<span class="pc" id="L417">			try(final PreparedStatement statement = this.databaseConnection.prepareStatement(&quot;SELECT DISTINCT zoom_level FROM gpkg_tile_matrix WHERE table_name = ? ORDER BY zoom_level;&quot;))</span>
			{
<span class="fc" id="L419">				statement.setString(1, tableName);</span>

<span class="pc" id="L421">				try(final ResultSet gmZoomLevels = statement.executeQuery())</span>
				{
<span class="fc bfc" id="L423" title="All 2 branches covered.">					while(gmZoomLevels.next())</span>
					{
<span class="fc" id="L425">						tileMatrixZooms.add(gmZoomLevels.getInt(&quot;zoom_level&quot;));</span>
					}
<span class="pc bpc" id="L427" title="6 of 8 branches missed.">				}</span>
<span class="pc bpc" id="L428" title="6 of 8 branches missed.">			}</span>

<span class="fc" id="L430">			final Collection&lt;Integer&gt; tilePyramidZooms = new LinkedList&lt;&gt;();</span>

<span class="pc" id="L432">			try(final Statement statement    = this.databaseConnection.createStatement();</span>
<span class="fc" id="L433">					final ResultSet pyZoomLevels = statement.executeQuery(String.format(&quot;SELECT DISTINCT zoom_level FROM '%s' ORDER BY zoom_level;&quot;, tableName)))</span>
			{
<span class="fc bfc" id="L435" title="All 2 branches covered.">				while(pyZoomLevels.next())</span>
				{
<span class="fc" id="L437">					tilePyramidZooms.add(pyZoomLevels.getInt(&quot;zoom_level&quot;));</span>
				}
<span class="pc bpc" id="L439" title="12 of 16 branches missed.">			}</span>

<span class="fc bfc" id="L441" title="All 2 branches covered.">			for(final Integer zoom: tilePyramidZooms)</span>
			{
<span class="fc" id="L443">				assertTrue(tileMatrixZooms.contains(zoom),</span>
<span class="fc" id="L444">						ErrorMessage.format(ErrorMessageKeys.MISSING_TILE_MATRIX_ENTRY, zoom, tableName));</span>
<span class="fc" id="L445">			}</span>
<span class="fc" id="L446">		}</span>
<span class="fc" id="L447">	}</span>

	/**
	 * The width of a tile matrix (the difference between {@code min_x} and
	 * {@code max_x} in {@code gpkg_tile_matrix_set}) SHALL equal the product
	 * of {@code matrix_width}, {@code tile_width}, and {@code pixel_x_size}
	 * for that zoom level. Similarly, height of a tile matrix (the difference
	 * between {@code min_y} and {@code max_y} in {@code gpkg_tile_matrix_set})
	 * SHALL equal the product of {@code matrix_height}, {@code tile_height},
	 * and {@code pixel_y_size} for that zoom level.
	 *
	 * @see &lt;a href=&quot;http://www.geopackage.org/spec/#_requirement-45&quot; target=
	 *      &quot;_blank&quot;&gt;Tile Matrix - Table Data Values - Requirement 45&lt;/a&gt;
	 *
	 * @throws SQLException
	 *             If an SQL query causes an error
	 */
	@Test(description = &quot;See OGC 12-128r12: Requirement 45&quot;)
	public void tileMatrixDimensionAgreement() throws SQLException
	{
<span class="fc" id="L467">		final Map&lt;String, Collection&lt;Integer&gt;&gt; tableNamesWithBadZooms = new HashMap&lt;&gt;();</span>

<span class="fc bfc" id="L469" title="All 2 branches covered.">		for(final String tableName : this.tileTableNames)</span>
		{
<span class="pc" id="L471">			try(final PreparedStatement preparedStatement = this.databaseConnection.prepareStatement(&quot;SELECT min_x, min_y, max_x, max_y FROM gpkg_tile_matrix_set WHERE table_name = ?&quot;))</span>
			{
<span class="fc" id="L473">				preparedStatement.setString(1, tableName);</span>

<span class="pc" id="L475">				try(final ResultSet boundingBox = preparedStatement.executeQuery())</span>
				{
<span class="pc bpc" id="L477" title="1 of 2 branches missed.">					if(boundingBox.next())</span>
					{
<span class="fc" id="L479">						final double width  = boundingBox.getDouble(&quot;max_x&quot;) - boundingBox.getDouble(&quot;min_x&quot;);</span>
<span class="fc" id="L480">						final double height = boundingBox.getDouble(&quot;max_y&quot;) - boundingBox.getDouble(&quot;min_y&quot;);</span>

<span class="fc" id="L482">						final Collection&lt;Integer&gt; zoomLevels = new ArrayList&lt;&gt;();</span>

<span class="pc" id="L484">						try(final PreparedStatement statement = this.databaseConnection.prepareStatement(&quot;SELECT zoom_level, pixel_x_size, pixel_y_size, matrix_width, matrix_height, tile_width, tile_height FROM gpkg_tile_matrix WHERE table_name = ? ORDER BY zoom_level ASC;&quot;))</span>
						{
<span class="fc" id="L486">							statement.setString(1, tableName);</span>

<span class="pc" id="L488">							try(final ResultSet pixelInfo = statement.executeQuery())</span>
							{
<span class="fc bfc" id="L490" title="All 2 branches covered.">								while(pixelInfo.next())</span>
								{
<span class="fc" id="L492">									final double pixelXSize   = pixelInfo.getDouble(&quot;pixel_x_size&quot;);</span>
<span class="fc" id="L493">									final double pixelYSize   = pixelInfo.getDouble(&quot;pixel_y_size&quot;);</span>
<span class="fc" id="L494">									final double matrixHeight = pixelInfo.getInt   (&quot;matrix_height&quot;);</span>
<span class="fc" id="L495">									final double matrixWidth  = pixelInfo.getInt   (&quot;matrix_width&quot;);</span>
<span class="fc" id="L496">									final double tileHeight   = pixelInfo.getInt   (&quot;tile_height&quot;);</span>
<span class="fc" id="L497">									final double tileWidth    = pixelInfo.getInt   (&quot;tile_width&quot;);</span>

<span class="pc bpc" id="L499" title="1 of 2 branches missed.">									if(!isEqual(pixelXSize, (width  / matrixWidth)  / tileWidth) ||</span>
<span class="pc bpc" id="L500" title="1 of 2 branches missed.">											!isEqual(pixelYSize, (height / matrixHeight) / tileHeight))</span>
									{
<span class="nc" id="L502">										zoomLevels.add(pixelInfo.getInt(&quot;zoom_level&quot;));</span>
									}
<span class="fc" id="L504">								}</span>
<span class="pc bpc" id="L505" title="6 of 8 branches missed.">							}</span>
<span class="pc bpc" id="L506" title="6 of 8 branches missed.">						}</span>

<span class="pc bpc" id="L508" title="1 of 2 branches missed.">						if(!zoomLevels.isEmpty())</span>
						{
<span class="nc" id="L510">							tableNamesWithBadZooms.put(tableName, zoomLevels);</span>
						}
					}
<span class="pc bpc" id="L513" title="6 of 8 branches missed.">				}</span>
<span class="pc bpc" id="L514" title="6 of 8 branches missed.">			}</span>
<span class="fc" id="L515">		}</span>

<span class="fc" id="L517">		assertTrue(tableNamesWithBadZooms.isEmpty(),</span>
<span class="fc" id="L518">				ErrorMessage.format(ErrorMessageKeys.BAD_PIXEL_DIMENSIONS,</span>
<span class="fc" id="L519">						tableNamesWithBadZooms.entrySet()</span>
<span class="fc" id="L520">						.stream()</span>
<span class="pc" id="L521">						.map(entrySet -&gt; String.format(&quot;%s: %s&quot;,</span>
<span class="nc" id="L522">								entrySet.getKey(),</span>
<span class="nc" id="L523">								entrySet.getValue()</span>
<span class="nc" id="L524">								.stream()</span>
<span class="nc" id="L525">								.map(Object::toString)</span>
<span class="nc" id="L526">								.collect(Collectors.joining(&quot;, &quot;))))</span>
<span class="fc" id="L527">						.collect(Collectors.joining(&quot;\n&quot;))));</span>
<span class="fc" id="L528">	}</span>

	/**
	 * The {@code zoom_level} column value in a {@code gpkg_tile_matrix} table
	 * row SHALL not be negative.
	 *
	 * @see &lt;a href=&quot;http://www.geopackage.org/spec/#_requirement-46&quot; target=
	 *      &quot;_blank&quot;&gt;Tile Matrix - Table Data Values - Requirement 46&lt;/a&gt;
	 *
	 * @throws SQLException
	 *             If an SQL query causes an error
	 */
	@Test(description = &quot;See OGC 12-128r12: Requirement 46&quot;)
	public void zoomLevelNotNegative() throws SQLException
	{
<span class="pc" id="L543">		try(final Statement statement = this.databaseConnection.createStatement();</span>
<span class="fc" id="L544">				final ResultSet resultSet = statement.executeQuery(&quot;SELECT zoom_level FROM gpkg_tile_matrix WHERE zoom_level &lt; 0;&quot;))</span>
		{
<span class="pc bpc" id="L546" title="1 of 2 branches missed.">			if(resultSet.next())</span>
			{
<span class="nc" id="L548">				fail(ErrorMessageKeys.NEGATIVE_ZOOM_LEVEL);</span>
			}
<span class="pc bpc" id="L550" title="12 of 16 branches missed.">		}</span>
<span class="fc" id="L551">	}</span>

	/**
	 * {@code matrix_width} column value in a {@code gpkg_tile_matrix} table
	 * row SHALL be greater than 0.
	 *
	 * @see &lt;a href=&quot;http://www.geopackage.org/spec/#_requirement-47&quot; target=
	 *      &quot;_blank&quot;&gt;Tile Matrix - Table Data Values - Requirement 47&lt;/a&gt;
	 *
	 * @throws SQLException
	 *             If an SQL query causes an error
	 */
	@Test(description = &quot;See OGC 12-128r12: Requirement 47&quot;)
	public void matrixWidthGreaterThanZero() throws SQLException
	{
<span class="pc" id="L566">		try(final Statement statement = this.databaseConnection.createStatement();</span>
<span class="fc" id="L567">				final ResultSet resultSet = statement.executeQuery(&quot;SELECT matrix_width FROM gpkg_tile_matrix WHERE matrix_width &lt;= 0;&quot;))</span>
		{
<span class="pc bpc" id="L569" title="1 of 2 branches missed.">			if(resultSet.next())</span>
			{
<span class="nc" id="L571">				fail(ErrorMessageKeys.NON_POSITIVE_MATRIX_WIDTH);</span>
			}
<span class="pc bpc" id="L573" title="12 of 16 branches missed.">		}</span>
<span class="fc" id="L574">	}</span>

	/**
	 * {@code matrix_height} column value in a {@code gpkg_tile_matrix} table
	 * row SHALL be greater than 0.
	 *
	 * @see &lt;a href=&quot;http://www.geopackage.org/spec/#_requirement-48&quot; target=
	 *      &quot;_blank&quot;&gt;Tile Matrix - Table Data Values - Requirement 48&lt;/a&gt;
	 *
	 * @throws SQLException
	 *             If an SQL query causes an error
	 */
	@Test(description = &quot;See OGC 12-128r12: Requirement 48&quot;)
	public void matrixHeightGreaterThanZero() throws SQLException
	{
<span class="pc" id="L589">		try(final Statement statement = this.databaseConnection.createStatement();</span>
<span class="fc" id="L590">				final ResultSet resultSet = statement.executeQuery(&quot;SELECT matrix_height FROM gpkg_tile_matrix WHERE matrix_height &lt;= 0;&quot;))</span>
		{
<span class="pc bpc" id="L592" title="1 of 2 branches missed.">			if(resultSet.next())</span>
			{
<span class="nc" id="L594">				fail(ErrorMessageKeys.NON_POSITIVE_MATRIX_HEIGHT);</span>
			}
<span class="pc bpc" id="L596" title="12 of 16 branches missed.">		}</span>
<span class="fc" id="L597">	}</span>

	/**
	 * {@code tile_width} column value in a {@code gpkg_tile_matrix} table row
	 * SHALL be greater than 0.
	 *
	 * @see &lt;a href=&quot;http://www.geopackage.org/spec/#_requirement-49&quot; target=
	 *      &quot;_blank&quot;&gt;Tile Matrix - Table Data Values - Requirement 49&lt;/a&gt;
	 *
	 * @throws SQLException
	 *             If an SQL query causes an error
	 */
	@Test(description = &quot;See OGC 12-128r12: Requirement 49&quot;)
	public void tileWidthGreaterThanZero() throws SQLException
	{
<span class="pc" id="L612">		try(final Statement statement = this.databaseConnection.createStatement();</span>
<span class="fc" id="L613">				final ResultSet resultSet = statement.executeQuery(&quot;SELECT tile_width FROM gpkg_tile_matrix WHERE tile_width &lt;= 0;&quot;))</span>
		{
<span class="pc bpc" id="L615" title="1 of 2 branches missed.">			if(resultSet.next())</span>
			{
<span class="nc" id="L617">				fail(ErrorMessageKeys.NON_POSITIVE_TILE_WIDTH);</span>
			}
<span class="pc bpc" id="L619" title="12 of 16 branches missed.">		}</span>
<span class="fc" id="L620">	}</span>

	/**
	 * {@code tile_height} column value in a {@code gpkg_tile_matrix} table row
	 * SHALL be greater than 0.
	 *
	 * @see &lt;a href=&quot;http://www.geopackage.org/spec/#_requirement-50&quot; target=
	 *      &quot;_blank&quot;&gt;Tile Matrix - Table Data Values - Requirement 50&lt;/a&gt;
	 *
	 * @throws SQLException
	 *             If an SQL query causes an error
	 */
	@Test(description = &quot;See OGC 12-128r12: Requirement 50&quot;)
	public void tileHeightGreaterThanZero() throws SQLException
	{
<span class="pc" id="L635">		try(final Statement statement = this.databaseConnection.createStatement();</span>
<span class="fc" id="L636">				final ResultSet resultSet = statement.executeQuery(&quot;SELECT tile_height FROM gpkg_tile_matrix WHERE tile_height &lt;= 0;&quot;))</span>
		{
<span class="pc bpc" id="L638" title="1 of 2 branches missed.">			if(resultSet.next())</span>
			{
<span class="nc" id="L640">				fail(ErrorMessageKeys.NON_POSITIVE_TILE_HEIGHT);</span>
			}
<span class="pc bpc" id="L642" title="12 of 16 branches missed.">		}</span>
<span class="fc" id="L643">	}</span>

	/**
	 * {@code pixel_x_size} column value in a {@code gpkg_tile_matrix} table row
	 * SHALL be greater than 0.
	 *
	 * @see &lt;a href=&quot;http://www.geopackage.org/spec/#_requirement-51&quot; target=
	 *      &quot;_blank&quot;&gt;Tile Matrix - Table Data Values - Requirement 51&lt;/a&gt;
	 *
	 * @throws SQLException
	 *             If an SQL query causes an error
	 */
	@Test(description = &quot;See OGC 12-128r12: Requirement 51&quot;)
	public void pixelXSizeGreaterThanZero() throws SQLException
	{
<span class="pc" id="L658">		try(final Statement statement = this.databaseConnection.createStatement();</span>
<span class="fc" id="L659">				final ResultSet resultSet = statement.executeQuery(&quot;SELECT pixel_x_size FROM gpkg_tile_matrix WHERE pixel_x_size &lt;= 0;&quot;))</span>
		{
<span class="pc bpc" id="L661" title="1 of 2 branches missed.">			if(resultSet.next())</span>
			{
<span class="nc" id="L663">				fail(ErrorMessageKeys.NON_POSITIVE_PIXEL_X_SIZE);</span>
			}
<span class="pc bpc" id="L665" title="12 of 16 branches missed.">		}</span>
<span class="fc" id="L666">	}</span>

	/**
	 * {@code pixel_y_size} column value in a {@code gpkg_tile_matrix} table row
	 * SHALL be greater than 0.
	 *
	 * @see &lt;a href=&quot;http://www.geopackage.org/spec/#_requirement-52&quot; target=
	 *      &quot;_blank&quot;&gt;Tile Matrix - Table Data Values - Requirement 52&lt;/a&gt;
	 *
	 * @throws SQLException
	 *             If an SQL query causes an error
	 */
	@Test(description = &quot;See OGC 12-128r12: Requirement 52&quot;)
	public void pixelYSizeGreaterThanZero() throws SQLException
	{
<span class="pc" id="L681">		try (</span>
<span class="fc" id="L682">				final Statement statement = this.databaseConnection.createStatement();</span>
<span class="fc" id="L683">				final ResultSet resultSet = statement.executeQuery(&quot;SELECT pixel_y_size FROM gpkg_tile_matrix WHERE pixel_y_size &lt;= 0;&quot;);</span>
				) {
<span class="pc bpc" id="L685" title="1 of 2 branches missed.">			if (resultSet.next()) {</span>
<span class="nc" id="L686">				fail(ErrorMessageKeys.NON_POSITIVE_PIXEL_Y_SIZE);</span>
			}    		
<span class="pc bpc" id="L688" title="12 of 16 branches missed.">		}</span>
<span class="fc" id="L689">	}</span>

	/**
	 * The {@code pixel_x_size} and {@code pixel_y_size} column values for
	 * {@code zoom_level} column values in a {@code gpkg_tile_matrix} table
	 * sorted in ascending order SHALL be sorted in descending order.
	 *
	 * @see &lt;a href=&quot;http://www.geopackage.org/spec/#_requirement-53&quot; target=
	 *      &quot;_blank&quot;&gt;Tile Matrix - Table Data Values - Requirement 53&lt;/a&gt;
	 *
	 * @throws SQLException
	 *             If an SQL query causes an error
	 *
	 */
	@Test(description = &quot;See OGC 12-128r12: Requirement 53&quot;)
	public void sortedPixelSizes() throws SQLException
	{
<span class="fc bfc" id="L706" title="All 2 branches covered.">		for(final String pyramidTable : this.tileTableNames) {</span>
<span class="pc" id="L707">			try (final PreparedStatement statement = this.databaseConnection.prepareStatement(&quot;SELECT pixel_x_size, pixel_y_size FROM gpkg_tile_matrix WHERE table_name = ? ORDER BY zoom_level ASC;&quot;)) {</span>
<span class="fc" id="L708">				statement.setString(1, pyramidTable);</span>
<span class="pc" id="L709">				try (final ResultSet resultSet = statement.executeQuery()) {</span>
<span class="pc bpc" id="L710" title="1 of 2 branches missed.">					if(resultSet.isBeforeFirst()) {</span>
<span class="fc" id="L711">						resultSet.next();</span>

<span class="fc" id="L713">						double lastPixelX = resultSet.getDouble(&quot;pixel_x_size&quot;);</span>
<span class="fc" id="L714">						double lastPixelY = resultSet.getDouble(&quot;pixel_y_size&quot;);</span>

<span class="fc bfc" id="L716" title="All 2 branches covered.">						while(resultSet.next()) {</span>
<span class="fc" id="L717">							final double pixelX = resultSet.getDouble(&quot;pixel_x_size&quot;);</span>
<span class="fc" id="L718">							final double pixelY = resultSet.getDouble(&quot;pixel_y_size&quot;);</span>

<span class="pc bpc" id="L720" title="2 of 4 branches missed.">							assertTrue(lastPixelX &gt; pixelX &amp;&amp; lastPixelY &gt; pixelY,</span>
<span class="fc" id="L721">									ErrorMessage.format(ErrorMessageKeys.PIXEL_SIZE_NOT_DECREASING, pyramidTable));</span>

<span class="fc" id="L723">							lastPixelX = pixelX;</span>
<span class="fc" id="L724">							lastPixelY = pixelY;</span>
<span class="fc" id="L725">						}</span>
					}                	
<span class="pc bpc" id="L727" title="6 of 8 branches missed.">				}</span>
<span class="pc bpc" id="L728" title="6 of 8 branches missed.">			}</span>
<span class="fc" id="L729">		}</span>
<span class="fc" id="L730">	}</span>

	/**
	 * Each tile matrix set in a GeoPackage SHALL be stored in a different tile
	 * pyramid user data table or updateable view with a unique name that SHALL
	 * have a column named &quot;id&quot; with column type INTEGER and &lt;em&gt;PRIMARY KEY
	 * AUTOINCREMENT&lt;/em&gt; column constraints per Clause 2.2.8.1.1 &lt;a
	 * href=&quot;http://www.geopackage.org/spec/#tiles_user_tables_data_table_definition&quot;&gt;
	 * Table Definition&lt;/a&gt;, &lt;a
	 * href=&quot;http://www.geopackage.org/spec/#example_tiles_table_cols&quot;&gt;Tiles
	 * Table or View Definition&lt;/a&gt; and &lt;a
	 * href=&quot;http://www.geopackage.org/spec/#example_tiles_table_insert_sql&quot;&gt;
	 * EXAMPLE: tiles table Insert Statement (Informative)&lt;/a&gt;.
	 *
	 * @see &lt;a href=&quot;http://www.geopackage.org/spec/#_requirement-54&quot; target=
	 *      &quot;_blank&quot;&gt;Tile Pyramid User Data Tables - Table Definition - Requirement 54&lt;/a&gt;
	 *
	 * @throws SQLException
	 *             If an SQL query causes an error
	 */
	@Test(description = &quot;See OGC 12-128r12: Requirement 54&quot;)
	public void tilesTableDefinitions() throws SQLException
	{
<span class="fc" id="L753">		final Map&lt;String, ColumnDefinition&gt; expectedColumns = new HashMap&lt;&gt;();</span>

<span class="fc" id="L755">		expectedColumns.put(&quot;id&quot;,          new ColumnDefinition(&quot;INTEGER&quot;, true, true,  true,  null));</span>
<span class="fc" id="L756">		expectedColumns.put(&quot;zoom_level&quot;,  new ColumnDefinition(&quot;INTEGER&quot;, true,  false, false, null));</span>
<span class="fc" id="L757">		expectedColumns.put(&quot;tile_column&quot;, new ColumnDefinition(&quot;INTEGER&quot;, true,  false, false, null));</span>
<span class="fc" id="L758">		expectedColumns.put(&quot;tile_row&quot;,    new ColumnDefinition(&quot;INTEGER&quot;, true,  false, false, null));</span>
<span class="fc" id="L759">		expectedColumns.put(&quot;tile_data&quot;,   new ColumnDefinition(&quot;BLOB&quot;,    true,  false, false, null));</span>

<span class="fc bfc" id="L761" title="All 2 branches covered.">		for(final String tableName : this.tileTableNames) {</span>
			try {
<span class="fc" id="L763">				TableVerifier.verifyTable(this.databaseConnection,</span>
						tableName,
						expectedColumns,
<span class="fc" id="L766">						Collections.emptySet(),</span>
<span class="fc" id="L767">						new HashSet&lt;&gt;(Arrays.asList(new UniqueDefinition(&quot;zoom_level&quot;, &quot;tile_column&quot;, &quot;tile_row&quot;))));</span>
			}
<span class="nc" id="L769">			catch(final Throwable th)</span>
			{
<span class="nc" id="L771">				fail(ErrorMessage.format(ErrorMessageKeys.BAD_TILE_PYRAMID_USER_DATA_TABLE_DEFINITION,</span>
						tableName,
<span class="nc" id="L773">						th.getMessage()));</span>
<span class="fc" id="L774">			}</span>
<span class="fc" id="L775">		}</span>
<span class="fc" id="L776">	}</span>

	/**
	 * For each distinct {@code table_name} from the {@code gpkg_tile_matrix}
	 * (tm) table, the tile pyramid (tp) user data table {@code zoom_level}
	 * column value in a GeoPackage SHALL be in the range {@code min(tm.zoom_level) &lt;=
	 * tp.zoom_level &lt;= max(tm.zoom_level)}.
	 *
	 * @see &lt;a href=&quot;http://www.geopackage.org/spec/#_requirement-55&quot; target=
	 *      &quot;_blank&quot;&gt;Tile Pyramid User Data Tables - Table Data Values - Requirement 55&lt;/a&gt;
	 *
	 * @throws SQLException
	 *             If an SQL query causes an error
	 */
	@Test(description = &quot;See OGC 12-128r12: Requirement 55&quot;)
	public void zoomLevelRange() throws SQLException
	{
<span class="fc bfc" id="L793" title="All 2 branches covered.">		for(final String tableName : this.tileTableNames) {</span>
			final boolean nullZoom;
			final int minZoom, maxZoom;




<span class="pc" id="L800">			try (final PreparedStatement statement = this.databaseConnection.prepareStatement(&quot;SELECT MIN(zoom_level) AS min_zoom, MAX(zoom_level) AS max_zoom FROM gpkg_tile_matrix WHERE table_name = ?;&quot;)) {</span>
<span class="fc" id="L801">				statement.setString(1, tableName);</span>
<span class="pc" id="L802">				try (final ResultSet minMaxZoom = statement.executeQuery()) {</span>
<span class="fc" id="L803">					minZoom = minMaxZoom.getInt(&quot;min_zoom&quot;);</span>
<span class="fc" id="L804">					maxZoom = minMaxZoom.getInt(&quot;max_zoom&quot;);    </span>
<span class="fc" id="L805">					nullZoom = minMaxZoom.wasNull();</span>
<span class="pc bpc" id="L806" title="6 of 8 branches missed.">				}</span>
<span class="pc bpc" id="L807" title="6 of 8 branches missed.">			}</span>


<span class="pc bpc" id="L810" title="1 of 2 branches missed.">			if (nullZoom) { return; }</span>

<span class="pc" id="L812">			try (final PreparedStatement zoomStatement = this.databaseConnection.prepareStatement(String.format(&quot;SELECT zoom_level FROM '%s' WHERE zoom_level &lt; ? OR zoom_level &gt; ?&quot;, tableName))) {</span>
<span class="fc" id="L813">				zoomStatement.setInt(1, minZoom);</span>
<span class="fc" id="L814">				zoomStatement.setInt(2, maxZoom);</span>

<span class="pc" id="L816">				try (final ResultSet invalidZooms = zoomStatement.executeQuery()) {</span>
<span class="pc bpc" id="L817" title="1 of 2 branches missed.">					if(invalidZooms.next())</span>
					{
<span class="nc" id="L819">						fail(ErrorMessage.format(ErrorMessageKeys.UNDEFINED_ZOOM_LEVEL,</span>
								tableName,
<span class="nc" id="L821">								invalidZooms.getInt(&quot;zoom_level&quot;)));</span>
					}                	
<span class="pc bpc" id="L823" title="6 of 8 branches missed.">				}        		</span>
<span class="pc bpc" id="L824" title="6 of 8 branches missed.">			}		</span>
<span class="fc" id="L825">		}</span>
<span class="fc" id="L826">	}</span>

	/**
	 * For each distinct {@code table_name} from the {@code gpkg_tile_matrix}
	 * (tm) table, the tile pyramid (tp) user data table {@code tile_column}
	 * column value in a GeoPackage SHALL be in the range {@code &lt;= tp.tile_column
	 * &lt;= tm.matrix_width - 1} where the tm and tp {@code zoom_level} column
	 * values are equal.
	 *
	 * @see &lt;a href=&quot;http://www.geopackage.org/spec/#_requirement-56&quot; target=
	 *      &quot;_blank&quot;&gt;Tile Pyramid User Data Tables - Table Data Values - Requirement 56&lt;/a&gt;
	 *
	 * @throws SQLException
	 *             If an SQL query causes an error
	 */
	@Test(description = &quot;See OGC 12-128r12: Requirement 56&quot;)
	public void tileColumnRange() throws SQLException
	{
<span class="fc bfc" id="L844" title="All 2 branches covered.">		for(final String tableName : this.tileTableNames)</span>
		{
<span class="fc" id="L846">			final String query = String.format(&quot;SELECT zoom_level as zl, matrix_width as width &quot; +</span>
					&quot;FROM   gpkg_tile_matrix &quot;        +
					&quot;WHERE  table_name = ? &quot;       +
					&quot;AND (zoom_level in (SELECT zoom_level FROM '%1$s' WHERE tile_column &lt; 0) &quot; +
					&quot;OR  (EXISTS(SELECT NULL FROM '%1$s' WHERE zoom_level = zl AND tile_column &gt; width - 1)));&quot;,
					tableName);

<span class="pc" id="L853">			try (final PreparedStatement statement = this.databaseConnection.prepareStatement(query)) {</span>
<span class="fc" id="L854">				statement.setString(1, tableName);</span>
<span class="pc" id="L855">				try (final ResultSet resultSet = statement.executeQuery()) {</span>
<span class="pc bpc" id="L856" title="1 of 2 branches missed.">					while(resultSet.next()) {</span>
<span class="nc" id="L857">						final int matrixWidth = resultSet.getInt(&quot;width&quot;);</span>
<span class="nc" id="L858">						final int zoomLevel   = resultSet.getInt(&quot;zl&quot;);</span>

<span class="nc" id="L860">						fail(ErrorMessage.format(ErrorMessageKeys.TILE_COLUMN_OUT_OF_RANGE,</span>
								tableName,
<span class="nc" id="L862">								matrixWidth-1,</span>
<span class="nc" id="L863">								zoomLevel));</span>
<span class="nc" id="L864">					}					</span>
<span class="pc bpc" id="L865" title="6 of 8 branches missed.">				}</span>
<span class="pc bpc" id="L866" title="6 of 8 branches missed.">			}</span>
<span class="fc" id="L867">		}</span>
<span class="fc" id="L868">	}</span>

	/**
	 * For each distinct {@code table_name} from the {@code gpkg_tile_matrix}
	 * (tm) table, the tile pyramid (tp) user data table {@code tile_row}
	 * column value in a GeoPackage SHALL be in the range {@code 0 &lt;= tp.tile_row &lt;=
	 * tm.matrix_height - 1} where the tm and tp {@code zoom_level} column
	 * values are equal.
	 *
	 * @see &lt;a href=&quot;http://www.geopackage.org/spec/#_requirement-57&quot; target=
	 *      &quot;_blank&quot;&gt;Tile Pyramid User Data Tables - Table Data Values - Requirement 57&lt;/a&gt;
	 *
	 * @throws SQLException
	 *             If an SQL query causes an error
	 */
	@Test(description = &quot;See OGC 12-128r12: Requirement 57&quot;)
	public void tileRowRange() throws SQLException
	{
<span class="fc bfc" id="L886" title="All 2 branches covered.">		for(final String tableName : this.tileTableNames)</span>
		{
<span class="fc" id="L888">			final String query = String.format(&quot;SELECT zoom_level as zl, matrix_height as height &quot; +</span>
					&quot;FROM   gpkg_tile_matrix &quot;        +
					&quot;WHERE  table_name = ? &quot;       +
					&quot;AND (zoom_level in (SELECT zoom_level FROM '%1$s' WHERE tile_row &lt; 0) &quot; +
					&quot;OR  (EXISTS(SELECT NULL FROM '%1$s' WHERE zoom_level = zl AND tile_row &gt; height - 1)));&quot;,
					tableName);

<span class="pc" id="L895">			try (final PreparedStatement statement = this.databaseConnection.prepareStatement(query)) {</span>
<span class="fc" id="L896">				statement.setString(1, tableName);</span>
<span class="pc" id="L897">				try (final ResultSet resultSet = statement.executeQuery()) {</span>
<span class="pc bpc" id="L898" title="1 of 2 branches missed.">					while(resultSet.next()) {</span>
<span class="nc" id="L899">						final int matrixHeight = resultSet.getInt(&quot;height&quot;);</span>
<span class="nc" id="L900">						final int zoomLevel   = resultSet.getInt(&quot;zl&quot;);</span>

<span class="nc" id="L902">						fail(ErrorMessage.format(ErrorMessageKeys.TILE_ROW_OUT_OF_RANGE,</span>
								tableName,
<span class="nc" id="L904">								matrixHeight-1,</span>
<span class="nc" id="L905">								zoomLevel));</span>
<span class="nc" id="L906">					}</span>
<span class="pc bpc" id="L907" title="6 of 8 branches missed.">				}</span>
<span class="pc bpc" id="L908" title="6 of 8 branches missed.">			}</span>
<span class="fc" id="L909">		}</span>
<span class="fc" id="L910">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>