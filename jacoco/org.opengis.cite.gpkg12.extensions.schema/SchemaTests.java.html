<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SchemaTests.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoPackage 1.2 Conformance Test Suite</a> &gt; <a href="index.source.html" class="el_package">org.opengis.cite.gpkg12.extensions.schema</a> &gt; <span class="el_source">SchemaTests.java</span></div><h1>SchemaTests.java</h1><pre class="source lang-java linenums">package org.opengis.cite.gpkg12.extensions.schema;

import static org.testng.Assert.assertTrue;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Arrays;
import java.util.List;

import org.opengis.cite.gpkg12.CommonFixture;
import org.opengis.cite.gpkg12.ErrorMessage;
import org.opengis.cite.gpkg12.ErrorMessageKeys;
import org.opengis.cite.gpkg12.util.GeoPackageVersion;
import org.opengis.cite.gpkg12.util.DatabaseUtility;
import org.testng.Assert;
import org.testng.ITestContext;
import org.testng.annotations.BeforeClass;
import org.testng.annotations.Test;

/**
 * Defines test methods that apply to descriptive information about a
 * GeoPackage's content as it pertains to the schema extension.
 *
 * &lt;p style=&quot;margin-bottom: 0.5em&quot;&gt;
 * &lt;strong&gt;Sources&lt;/strong&gt;
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;&lt;a href=&quot;http://www.geopackage.org/spec/#extension_schema&quot; target= &quot;_blank&quot;&gt;
 * GeoPackage Encoding Standard - F.9. Schema&lt;/a&gt; (OGC 12-128r13)&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * @author Jeff Yutzler
 */
<span class="fc" id="L35">public class SchemaTests extends CommonFixture</span>
{
    @BeforeClass
    public void activeExtension(ITestContext testContext) throws SQLException {
    	// Starting with GPKG 1.1, this is a proper extension.
<span class="fc bfc" id="L40" title="All 2 branches covered.">    	if (geopackageVersion == GeoPackageVersion.V102) {</span>
<span class="fc" id="L41">			Assert.assertTrue(DatabaseUtility.doesTableOrViewExist(this.databaseConnection, &quot;gpkg_data_columns&quot;), </span>
<span class="fc" id="L42">					ErrorMessage.format(ErrorMessageKeys.CONFORMANCE_CLASS_NOT_USED, &quot;Schema Option&quot;));</span>
<span class="fc" id="L43">    		minIsInclusive = &quot;minIsInclusive&quot;;</span>
<span class="fc" id="L44">    		maxIsInclusive = &quot;maxIsInclusive&quot;;</span>
    	} else {
<span class="fc" id="L46">    		Assert.assertTrue(DatabaseUtility.doesTableOrViewExist(this.databaseConnection, &quot;gpkg_extensions&quot;), </span>
<span class="fc" id="L47">    				ErrorMessage.format(ErrorMessageKeys.CONFORMANCE_CLASS_NOT_USED, &quot;Schema Extension&quot;));</span>
			
<span class="fc" id="L49">			try (</span>
<span class="fc" id="L50">					final Statement statement = this.databaseConnection.createStatement();</span>
					
<span class="fc" id="L52">					final ResultSet resultSet = statement.executeQuery(&quot;SELECT count(*) from gpkg_extensions WHERE extension_name = 'gpkg_schema';&quot;);</span>
					) {
<span class="fc" id="L54">				resultSet.next();</span>
				
<span class="fc bfc" id="L56" title="All 2 branches covered.">				Assert.assertTrue(resultSet.getInt(1) &gt; 0, ErrorMessage.format(ErrorMessageKeys.CONFORMANCE_CLASS_NOT_USED, &quot;Schema Extension&quot;));				</span>
<span class="pc bpc" id="L57" title="8 of 16 branches missed.">			}</span>
<span class="fc" id="L58">    		minIsInclusive = &quot;min_is_inclusive&quot;;</span>
<span class="fc" id="L59">    		maxIsInclusive = &quot;max_is_inclusive&quot;;</span>
    	}
<span class="fc" id="L61">    }</span>

    /**
     * A GeoPackage MAY contain a table or updateable view named 
     * gpkg_data_columns. If present it SHALL be defined per clause 2.3.2.1.1 
     * Table Definition, Data Columns Table or View Definition and 
     * gpkg_data_columns Table Definition SQL.
     * 
     * @see &lt;a href=&quot;http://www.geopackage.org/spec/#r103&quot; target=
     *      &quot;_blank&quot;&gt;F.9. Schema - Requirement 103&lt;/a&gt;
     *
     * @throws SQLException
     *             If an SQL query causes an error
     */
    @Test(description = &quot;See OGC 12-128r13: Requirement 103&quot;)
    public void dataColumnsTableDefinition() throws SQLException
    {
<span class="pc" id="L78">    	try (</span>
    			// 1
<span class="fc" id="L80">    			final Statement statement = this.databaseConnection.createStatement();</span>

<span class="fc" id="L82">    			final ResultSet resultSet = statement.executeQuery(&quot;PRAGMA table_info('gpkg_data_columns');&quot;);</span>
    			) {
    		// 2
<span class="fc" id="L85">    		int passFlag = 0;</span>
<span class="fc" id="L86">    		final int flagMask = 0b01111111;</span>
    		
<span class="fc bfc" id="L88" title="All 2 branches covered.">    		while (resultSet.next()) {</span>
    			// 3
<span class="fc" id="L90">    			final String name = resultSet.getString(&quot;name&quot;);</span>
<span class="fc bfc" id="L91" title="All 2 branches covered.">    			if (&quot;table_name&quot;.equals(name)){</span>
<span class="fc" id="L92">    				assertTrue(&quot;TEXT&quot;.equals(resultSet.getString(&quot;type&quot;)), ErrorMessage.format(ErrorMessageKeys.TABLE_DEFINITION_INVALID, &quot;gpkg_data_columns&quot;, &quot;table_name type&quot;));</span>
<span class="pc bpc" id="L93" title="1 of 2 branches missed.">    				assertTrue(resultSet.getInt(&quot;notnull&quot;) == 1, ErrorMessage.format(ErrorMessageKeys.TABLE_DEFINITION_INVALID, &quot;gpkg_data_columns&quot;, &quot;table_name notnull&quot;));</span>
<span class="pc bpc" id="L94" title="1 of 2 branches missed.">    				assertTrue(resultSet.getInt(&quot;pk&quot;) &gt; 0, ErrorMessage.format(ErrorMessageKeys.TABLE_DEFINITION_INVALID, &quot;gpkg_data_columns&quot;, &quot;table_name pk&quot;));</span>
<span class="fc" id="L95">    				passFlag |= 1;</span>
<span class="fc bfc" id="L96" title="All 2 branches covered.">    			} else if (&quot;column_name&quot;.equals(name)){</span>
<span class="fc" id="L97">    				assertTrue(&quot;TEXT&quot;.equals(resultSet.getString(&quot;type&quot;)), ErrorMessage.format(ErrorMessageKeys.TABLE_DEFINITION_INVALID, &quot;gpkg_data_columns&quot;, &quot;column_name type&quot;));</span>
<span class="pc bpc" id="L98" title="1 of 2 branches missed.">    				assertTrue(resultSet.getInt(&quot;notnull&quot;) == 1, ErrorMessage.format(ErrorMessageKeys.TABLE_DEFINITION_INVALID, &quot;gpkg_data_columns&quot;, &quot;column_name notnull&quot;));</span>
<span class="pc bpc" id="L99" title="1 of 2 branches missed.">    				assertTrue(resultSet.getInt(&quot;pk&quot;) &gt; 0, ErrorMessage.format(ErrorMessageKeys.TABLE_DEFINITION_INVALID, &quot;gpkg_data_columns&quot;, &quot;column_name pk&quot;));</span>
<span class="fc" id="L100">    				passFlag |= (1 &lt;&lt; 1);</span>
<span class="fc bfc" id="L101" title="All 2 branches covered.">    			} else if (&quot;name&quot;.equals(name)){</span>
<span class="fc" id="L102">    				assertTrue(&quot;TEXT&quot;.equals(resultSet.getString(&quot;type&quot;)), ErrorMessage.format(ErrorMessageKeys.TABLE_DEFINITION_INVALID, &quot;gpkg_data_columns&quot;, &quot;name type&quot;));</span>

    				// Huh? How can a unique value be allowed to be null?
<span class="pc bpc" id="L105" title="1 of 2 branches missed.">    				assertTrue(resultSet.getInt(&quot;notnull&quot;) == 0, ErrorMessage.format(ErrorMessageKeys.TABLE_DEFINITION_INVALID, &quot;gpkg_data_columns&quot;, &quot;name notnull&quot;));</span>
    				
    				// unique constraint??
<span class="fc" id="L108">    				passFlag |= (1 &lt;&lt; 2);</span>
<span class="fc bfc" id="L109" title="All 2 branches covered.">    			} else if (&quot;title&quot;.equals(name)){</span>
<span class="fc" id="L110">    				assertTrue(&quot;TEXT&quot;.equals(resultSet.getString(&quot;type&quot;)), ErrorMessage.format(ErrorMessageKeys.TABLE_DEFINITION_INVALID, &quot;gpkg_data_columns&quot;, &quot;title type&quot;));</span>
<span class="pc bpc" id="L111" title="1 of 2 branches missed.">    				assertTrue(resultSet.getInt(&quot;notnull&quot;) == 0, ErrorMessage.format(ErrorMessageKeys.TABLE_DEFINITION_INVALID, &quot;gpkg_data_columns&quot;, &quot;title notnull&quot;));</span>
<span class="fc" id="L112">    				passFlag |= (1 &lt;&lt; 3);</span>
<span class="fc bfc" id="L113" title="All 2 branches covered.">    			} else if (&quot;description&quot;.equals(name)){</span>
<span class="fc" id="L114">    				assertTrue(&quot;TEXT&quot;.equals(resultSet.getString(&quot;type&quot;)), ErrorMessage.format(ErrorMessageKeys.TABLE_DEFINITION_INVALID, &quot;gpkg_data_columns&quot;, &quot;description type&quot;));</span>
<span class="pc bpc" id="L115" title="1 of 2 branches missed.">    				assertTrue(resultSet.getInt(&quot;notnull&quot;) == 0, ErrorMessage.format(ErrorMessageKeys.TABLE_DEFINITION_INVALID, &quot;gpkg_data_columns&quot;, &quot;description notnull&quot;));</span>
<span class="fc" id="L116">    				passFlag |= (1 &lt;&lt; 4);</span>
<span class="fc bfc" id="L117" title="All 2 branches covered.">    			} else if (&quot;mime_type&quot;.equals(name)){</span>
<span class="fc" id="L118">    				assertTrue(&quot;TEXT&quot;.equals(resultSet.getString(&quot;type&quot;)), ErrorMessage.format(ErrorMessageKeys.TABLE_DEFINITION_INVALID, &quot;gpkg_data_columns&quot;, &quot;mime_type type&quot;));</span>
<span class="pc bpc" id="L119" title="1 of 2 branches missed.">    				assertTrue(resultSet.getInt(&quot;notnull&quot;) == 0, ErrorMessage.format(ErrorMessageKeys.TABLE_DEFINITION_INVALID, &quot;gpkg_data_columns&quot;, &quot;mime_type notnull&quot;));</span>
<span class="fc" id="L120">    				passFlag |= (1 &lt;&lt; 5);</span>
<span class="pc bpc" id="L121" title="1 of 2 branches missed.">    			} else if (&quot;constraint_name&quot;.equals(name)){</span>
<span class="fc" id="L122">    				assertTrue(&quot;TEXT&quot;.equals(resultSet.getString(&quot;type&quot;)), ErrorMessage.format(ErrorMessageKeys.TABLE_DEFINITION_INVALID, &quot;gpkg_data_columns&quot;, &quot;constraint_name type&quot;));</span>
<span class="pc bpc" id="L123" title="1 of 2 branches missed.">    				assertTrue(resultSet.getInt(&quot;notnull&quot;) == 0, ErrorMessage.format(ErrorMessageKeys.TABLE_DEFINITION_INVALID, &quot;gpkg_data_columns&quot;, &quot;constraint_name notnull&quot;));</span>
<span class="fc" id="L124">    				passFlag |= (1 &lt;&lt; 6);</span>
    			}
<span class="fc" id="L126">    		} </span>
<span class="pc bpc" id="L127" title="1 of 2 branches missed.">    		assertTrue((passFlag &amp; flagMask) == flagMask, ErrorMessage.format(ErrorMessageKeys.TABLE_DEFINITION_INVALID, &quot;gpkg_data_columns&quot;, &quot;missing column(s)&quot;));</span>
<span class="pc bpc" id="L128" title="12 of 16 branches missed.">    	}</span>
<span class="fc" id="L129">    }</span>


    /**
     * Values of the gpkg_data_columns table table_name column value SHALL 
     * reference values in the gpkg_contents table_name column.
     * 
     * @see &lt;a href=&quot;http://www.geopackage.org/spec/#r104&quot; target=
     *      &quot;_blank&quot;&gt;F.9. Schema - Requirement 104&lt;/a&gt;
     *
     * @throws SQLException
     *             If an SQL query causes an error
     */
    @Test(description = &quot;See OGC 12-128r13: Requirement 104&quot;)
    public void dataColumnsTableName() throws SQLException
    {
<span class="pc" id="L145">    	try (</span>
    	    	// 1
<span class="fc" id="L147">    			final Statement statement1 = this.databaseConnection.createStatement();</span>

<span class="fc" id="L149">    			final ResultSet resultSet1 = statement1.executeQuery(&quot;SELECT DISTINCT gdc.table_name AS gdc_table, gc.table_name AS gc_table FROM gpkg_data_columns AS gdc LEFT OUTER JOIN gpkg_contents AS gc ON gdc.table_name = gc.table_name;&quot;);</span>
    			) {
    		// 2
<span class="fc bfc" id="L152" title="All 2 branches covered.">    		while (resultSet1.next()) {</span>
    			// 3
<span class="fc" id="L154">    			final String gcTable = resultSet1.getString(&quot;gc_table&quot;);</span>
<span class="fc" id="L155">    			final String gdcTable = resultSet1.getString(&quot;gdc_table&quot;);</span>

    			// 3a
<span class="pc bpc" id="L158" title="1 of 2 branches missed.">    			assertTrue(gcTable != null, ErrorMessage.format(ErrorMessageKeys.INVALID_DATA_TABLE, &quot;gpkg_data_columns&quot;, gdcTable));</span>
<span class="fc" id="L159">    		}</span>
<span class="pc bpc" id="L160" title="12 of 16 branches missed.">    	}</span>
<span class="fc" id="L161">    }</span>
    
    /**
     * The `column_name` column value in a `gpkg_data_columns` table row 
     * SHALL contain the name of a column in the SQLite table or view 
     * identified by the `table_name` column value.
     * 
     * @see &lt;a href=&quot;http://www.geopackage.org/spec/#r105&quot; target=
     *      &quot;_blank&quot;&gt;F.9. Schema - Requirement 105&lt;/a&gt;
     *
     * @throws SQLException
     *             If an SQL query causes an error
     */
    @Test(description = &quot;See OGC 12-128r13: Requirement 105&quot;)
    public void dataColumnsColumnName() throws SQLException
    {
<span class="fc" id="L177">    	try (</span>
    	    	// 1
<span class="fc" id="L179">    			final Statement statement1 = this.databaseConnection.createStatement();</span>

<span class="fc" id="L181">    			final ResultSet resultSet1 = statement1.executeQuery(&quot;SELECT table_name, column_name FROM gpkg_data_columns;&quot;);</span>
    			) {
    		// 2
<span class="fc bfc" id="L184" title="All 2 branches covered.">    		while (resultSet1.next()) {</span>
<span class="fc" id="L185">    			final String columnName = resultSet1.getString(&quot;column_name&quot;);</span>
<span class="fc" id="L186">    			final String tableName = resultSet1.getString(&quot;table_name&quot;);</span>

    			// 3
<span class="fc" id="L189">    			try (final Statement statement2 = this.databaseConnection.createStatement()){</span>
    				// 3bi
<span class="fc" id="L191">    				statement2.executeQuery(String.format(&quot;SELECT COUNT(%s) from %s;&quot;, columnName, tableName));</span>
<span class="pc bpc" id="L192" title="4 of 8 branches missed.">    			} catch (SQLException exc) {</span>
<span class="nc" id="L193">    				Assert.fail(ErrorMessage.format(ErrorMessageKeys.INVALID_DATA_COLUMN, &quot;gpkg_extensions&quot;, columnName, tableName));</span>
<span class="fc" id="L194">    			}</span>
<span class="fc" id="L195">    		}</span>
<span class="pc bpc" id="L196" title="8 of 16 branches missed.">    	}</span>
<span class="fc" id="L197">    }</span>
    
    /**
     * A GeoPackage MAY contain a table or updateable view named 
     * gpkg_data_column_constraints. If present it SHALL be defined per 
     * clause 2.3.3.1.1 Table Definition, Data Column Constraints Table or 
     * View Definition and gpkg_data_columns Table Definition SQL.
     * 
     * @see &lt;a href=&quot;http://www.geopackage.org/spec/#r107&quot; target=
     *      &quot;_blank&quot;&gt;F.9. Schema - Requirement 107&lt;/a&gt;
     *
     * @throws SQLException
     *             If an SQL query causes an error
     */
    @Test(description = &quot;See OGC 12-128r13: Requirement 107&quot;)
    public void dataColumnConstraintsTableDefinition() throws SQLException
    {
<span class="pc" id="L214">    	try (</span>
    			// 1
<span class="fc" id="L216">    			final Statement statement = this.databaseConnection.createStatement();</span>

<span class="fc" id="L218">    			final ResultSet resultSet = statement.executeQuery(&quot;PRAGMA table_info('gpkg_data_column_constraints');&quot;);</span>
    			) {
    		// 2
<span class="fc" id="L221">    		int passFlag = 0;</span>
<span class="fc" id="L222">    		final int flagMask = 0b11111111;</span>
    		
<span class="fc bfc" id="L224" title="All 2 branches covered.">    		while (resultSet.next()) {</span>
    			// 3
<span class="fc" id="L226">    			final String name = resultSet.getString(&quot;name&quot;);</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">    			if (&quot;constraint_name&quot;.equals(name)){</span>
<span class="fc" id="L228">    				assertTrue(&quot;TEXT&quot;.equals(resultSet.getString(&quot;type&quot;)), ErrorMessage.format(ErrorMessageKeys.TABLE_DEFINITION_INVALID, &quot;gpkg_data_column_constraints&quot;, &quot;constraint_name type&quot;));</span>
<span class="pc bpc" id="L229" title="1 of 2 branches missed.">    				assertTrue(resultSet.getInt(&quot;notnull&quot;) == 1, ErrorMessage.format(ErrorMessageKeys.TABLE_DEFINITION_INVALID, &quot;gpkg_data_column_constraints&quot;, &quot;constraint_name notnull&quot;));</span>
<span class="fc" id="L230">    				passFlag |= 1;</span>
<span class="fc bfc" id="L231" title="All 2 branches covered.">    			} else if (&quot;constraint_type&quot;.equals(name)){</span>
<span class="fc" id="L232">    				assertTrue(&quot;TEXT&quot;.equals(resultSet.getString(&quot;type&quot;)), ErrorMessage.format(ErrorMessageKeys.TABLE_DEFINITION_INVALID, &quot;gpkg_data_column_constraints&quot;, &quot;constraint_type type&quot;));</span>
<span class="pc bpc" id="L233" title="1 of 2 branches missed.">    				assertTrue(resultSet.getInt(&quot;notnull&quot;) == 1, ErrorMessage.format(ErrorMessageKeys.TABLE_DEFINITION_INVALID, &quot;gpkg_data_column_constraints&quot;, &quot;constraint_type notnull&quot;));</span>
<span class="fc" id="L234">    				passFlag |= (1 &lt;&lt; 1);</span>
<span class="fc bfc" id="L235" title="All 2 branches covered.">    			} else if (&quot;value&quot;.equals(name)){</span>
<span class="fc" id="L236">    				assertTrue(&quot;TEXT&quot;.equals(resultSet.getString(&quot;type&quot;)), ErrorMessage.format(ErrorMessageKeys.TABLE_DEFINITION_INVALID, &quot;gpkg_data_column_constraints&quot;, &quot;value type&quot;));</span>

    				// Huh? How can a unique value be allowed to be null?
<span class="pc bpc" id="L239" title="1 of 2 branches missed.">    				assertTrue(resultSet.getInt(&quot;notnull&quot;) == 0, ErrorMessage.format(ErrorMessageKeys.TABLE_DEFINITION_INVALID, &quot;gpkg_data_column_constraints&quot;, &quot;value notnull&quot;));</span>
    				
    				// unique constraint??
<span class="fc" id="L242">    				passFlag |= (1 &lt;&lt; 2);</span>
<span class="fc bfc" id="L243" title="All 2 branches covered.">    			} else if (&quot;min&quot;.equals(name)){</span>
<span class="fc" id="L244">    				assertTrue(&quot;NUMERIC&quot;.equals(resultSet.getString(&quot;type&quot;)), ErrorMessage.format(ErrorMessageKeys.TABLE_DEFINITION_INVALID, &quot;gpkg_data_column_constraints&quot;, &quot;min type&quot;));</span>
<span class="pc bpc" id="L245" title="1 of 2 branches missed.">    				assertTrue(resultSet.getInt(&quot;notnull&quot;) == 0, ErrorMessage.format(ErrorMessageKeys.TABLE_DEFINITION_INVALID, &quot;gpkg_data_column_constraints&quot;, &quot;min notnull&quot;));</span>
<span class="fc" id="L246">    				passFlag |= (1 &lt;&lt; 3);</span>
<span class="fc bfc" id="L247" title="All 2 branches covered.">    			} else if (minIsInclusive.equalsIgnoreCase(name)){</span>
<span class="fc" id="L248">    				assertTrue(&quot;BOOLEAN&quot;.equals(resultSet.getString(&quot;type&quot;)), ErrorMessage.format(ErrorMessageKeys.TABLE_DEFINITION_INVALID, &quot;gpkg_data_column_constraints&quot;, minIsInclusive + &quot; type&quot;));</span>
<span class="pc bpc" id="L249" title="1 of 2 branches missed.">    				assertTrue(resultSet.getInt(&quot;notnull&quot;) == 0, ErrorMessage.format(ErrorMessageKeys.TABLE_DEFINITION_INVALID, &quot;gpkg_data_column_constraints&quot;, minIsInclusive + &quot; notnull&quot;));</span>
<span class="fc" id="L250">    				passFlag |= (1 &lt;&lt; 4);</span>
<span class="fc bfc" id="L251" title="All 2 branches covered.">    			} else if (&quot;max&quot;.equals(name)){</span>
<span class="fc" id="L252">    				assertTrue(&quot;NUMERIC&quot;.equals(resultSet.getString(&quot;type&quot;)), ErrorMessage.format(ErrorMessageKeys.TABLE_DEFINITION_INVALID, &quot;gpkg_data_column_constraints&quot;, &quot;max type&quot;));</span>
<span class="pc bpc" id="L253" title="1 of 2 branches missed.">    				assertTrue(resultSet.getInt(&quot;notnull&quot;) == 0, ErrorMessage.format(ErrorMessageKeys.TABLE_DEFINITION_INVALID, &quot;gpkg_data_column_constraints&quot;, &quot;max notnull&quot;));</span>
<span class="fc" id="L254">    				passFlag |= (1 &lt;&lt; 5);</span>
<span class="fc bfc" id="L255" title="All 2 branches covered.">    			} else if (maxIsInclusive.equalsIgnoreCase(name)){</span>
<span class="fc" id="L256">    				assertTrue(&quot;BOOLEAN&quot;.equals(resultSet.getString(&quot;type&quot;)), ErrorMessage.format(ErrorMessageKeys.TABLE_DEFINITION_INVALID, &quot;gpkg_data_column_constraints&quot;, maxIsInclusive + &quot; type&quot;));</span>
<span class="pc bpc" id="L257" title="1 of 2 branches missed.">    				assertTrue(resultSet.getInt(&quot;notnull&quot;) == 0, ErrorMessage.format(ErrorMessageKeys.TABLE_DEFINITION_INVALID, &quot;gpkg_data_column_constraints&quot;, maxIsInclusive + &quot; notnull&quot;));</span>
<span class="fc" id="L258">    				passFlag |= (1 &lt;&lt; 6);</span>
<span class="pc bpc" id="L259" title="1 of 2 branches missed.">    			} else if (&quot;description&quot;.equals(name)){</span>
<span class="fc" id="L260">    				assertTrue(&quot;TEXT&quot;.equals(resultSet.getString(&quot;type&quot;)), ErrorMessage.format(ErrorMessageKeys.TABLE_DEFINITION_INVALID, &quot;gpkg_data_column_constraints&quot;, &quot;description type&quot;));</span>
<span class="pc bpc" id="L261" title="1 of 2 branches missed.">    				assertTrue(resultSet.getInt(&quot;notnull&quot;) == 0, ErrorMessage.format(ErrorMessageKeys.TABLE_DEFINITION_INVALID, &quot;gpkg_data_column_constraints&quot;, &quot;description notnull&quot;));</span>
<span class="fc" id="L262">    				passFlag |= (1 &lt;&lt; 7);</span>
    			}
<span class="fc" id="L264">    		} </span>
<span class="pc bpc" id="L265" title="1 of 2 branches missed.">    		assertTrue((passFlag &amp; flagMask) == flagMask, ErrorMessage.format(ErrorMessageKeys.TABLE_DEFINITION_INVALID, &quot;gpkg_data_column_constraints&quot;, &quot;missing column(s)&quot;));</span>
<span class="pc bpc" id="L266" title="10 of 16 branches missed.">    	}</span>
<span class="fc" id="L267">    }</span>

    /**
     * The gpkg_data_column_constraints table MAY be empty. If it contains 
     * data, the lowercase constraint_type column values SHALL be one of 
     * &quot;range&quot;, &quot;enum&quot;, or &quot;glob&quot;.
     * 
     * @see &lt;a href=&quot;http://www.geopackage.org/spec/#r108&quot; target=
     *      &quot;_blank&quot;&gt;F.9. Schema - Requirement 108&lt;/a&gt;
     *
     * @throws SQLException
     *             If an SQL query causes an error
     */
    @Test(description = &quot;See OGC 12-128r13: Requirement 108&quot;)
    public void dataColumnConstraintsType() throws SQLException
    {
<span class="pc" id="L283">    	try (</span>
    	    	// 1
<span class="fc" id="L285">    			final Statement statement1 = this.databaseConnection.createStatement();</span>

<span class="fc" id="L287">    			final ResultSet resultSet1 = statement1.executeQuery(&quot;SELECT DISTINCT constraint_type FROM gpkg_data_column_constraints&quot;);</span>
    			) {
    		// 2
<span class="pc bpc" id="L290" title="1 of 2 branches missed.">    		while (resultSet1.next()) {</span>
    			// 3
<span class="nc" id="L292">    			final String constraintType = resultSet1.getString(&quot;constraint_type&quot;);</span>

<span class="nc" id="L294">    			Assert.assertTrue(AllowedConstraintTypes.contains(constraintType), </span>
<span class="nc" id="L295">    					ErrorMessage.format(ErrorMessageKeys.UNEXPECTED_VALUE, constraintType, &quot;constraint_type&quot;, &quot;gpkg_data_column_constraints&quot;));</span>
<span class="nc" id="L296">    		}    		</span>
<span class="pc bpc" id="L297" title="10 of 16 branches missed.">    	}</span>
<span class="fc" id="L298">    }</span>

    /**
     * gpkg_data_column_constraint constraint_name values for rows with 
     * constraint_type values of &quot;range&quot; and &quot;glob&quot; SHALL be unique.
     * 
     * @see &lt;a href=&quot;http://www.geopackage.org/spec/#r109&quot; target=
     *      &quot;_blank&quot;&gt;F.9. Schema - Requirement 109&lt;/a&gt;
     *
     * @throws SQLException
     *             If an SQL query causes an error
     */
    @Test(description = &quot;See OGC 12-128r13: Requirement 109&quot;)
    public void dataColumnConstraintsName() throws SQLException
    {
<span class="pc" id="L313">    	try (</span>
    	    	// 1
<span class="fc" id="L315">    			final Statement statement1 = this.databaseConnection.createStatement();</span>

<span class="fc" id="L317">    			final ResultSet resultSet1 = statement1.executeQuery(&quot;SELECT DISTINCT constraint_name FROM gpkg_data_column_constraints WHERE constraint_type IN ('range', 'glob')&quot;);</span>
    			) {
    		// 2
<span class="pc bpc" id="L320" title="1 of 2 branches missed.">    		while (resultSet1.next()) {</span>
    			// 3
<span class="nc" id="L322">    			final String constraintName = resultSet1.getString(&quot;constraint_name&quot;);</span>

<span class="nc" id="L324">    			try (</span>
<span class="nc" id="L325">    					final Statement statement2 = this.databaseConnection.createStatement();</span>

<span class="nc" id="L327">    					final ResultSet resultSet2 = statement2.executeQuery(String.format(&quot;SELECT COUNT(*) FROM gpkg_data_column_constraints WHERE constraint_name = '%s'&quot;, constraintName));</span>
    					) {
<span class="nc bnc" id="L329" title="All 2 branches missed.">    				Assert.assertTrue(resultSet2.getInt(1) &lt;= 1, </span>
<span class="nc" id="L330">    						ErrorMessage.format(ErrorMessageKeys.NON_UNIQUE_VALUE, &quot;constraint_name&quot;, &quot;gpkg_data_column_constraints&quot;, constraintName));</span>
<span class="nc bnc" id="L331" title="All 16 branches missed.">    			}</span>
<span class="nc" id="L332">    		}</span>
<span class="pc bpc" id="L333" title="10 of 16 branches missed.">    	}</span>
<span class="fc" id="L334">    }</span>

    /**
     * The gpkg_data_column_constraints table MAY be empty. If it contains 
     * rows with constraint_type column values of &quot;range&quot;, the value column 
     * values for those rows SHALL be NULL.
     * 
     * @see &lt;a href=&quot;http://www.geopackage.org/spec/#r110&quot; target=
     *      &quot;_blank&quot;&gt;F.9. Schema - Requirement 110&lt;/a&gt;
     *
     * @throws SQLException
     *             If an SQL query causes an error
     */
    @Test(description = &quot;See OGC 12-128r13: Requirement 110&quot;)
    public void dataColumnConstraintsValue() throws SQLException
    {
<span class="pc" id="L350">    	try (</span>
    	    	// 1
<span class="fc" id="L352">    			final Statement statement1 = this.databaseConnection.createStatement();</span>

<span class="fc" id="L354">    			final ResultSet resultSet1 = statement1.executeQuery(&quot;SELECT constraint_name, value FROM gpkg_data_column_constraints WHERE constraint_type = 'range'&quot;);</span>
    			) {
    		// 2
<span class="pc bpc" id="L357" title="1 of 2 branches missed.">    		while (resultSet1.next()) {</span>
    			// 3
<span class="nc" id="L359">    			final String constraintName = resultSet1.getString(&quot;constraint_name&quot;);</span>
<span class="nc" id="L360">    			final String value = resultSet1.getString(&quot;value&quot;);</span>

<span class="nc bnc" id="L362" title="All 2 branches missed.">    			Assert.assertTrue(value == null, </span>
<span class="nc" id="L363">    					ErrorMessage.format(ErrorMessageKeys.CONSTRAINT_NON_NULL_VALUE, constraintName));</span>
<span class="nc" id="L364">    		}</span>
<span class="pc bpc" id="L365" title="10 of 16 branches missed.">    	}</span>
<span class="fc" id="L366">    }</span>

    /**
     * If the `gpkg_data_column_constraints` table contains rows with 
     * `constraint_type` column values of &quot;range&quot;, the `min` column values 
     * for those rows SHALL be NOT NULL and less than the `max` column value 
     * which shall be NOT NULL.
     * 
     * @see &lt;a href=&quot;http://www.geopackage.org/spec/#r111&quot; target=
     *      &quot;_blank&quot;&gt;F.9. Schema - Requirement 111&lt;/a&gt;
     *
     * @throws SQLException
     *             If an SQL query causes an error
     */
    @Test(description = &quot;See OGC 12-128r13: Requirement 111&quot;)
    public void dataColumnConstraintsMinMax() throws SQLException
    {
<span class="pc" id="L383">    	try (</span>
    	    	// 1
<span class="fc" id="L385">    			final Statement statement1 = this.databaseConnection.createStatement();</span>

<span class="fc" id="L387">    			final ResultSet resultSet1 = statement1.executeQuery(&quot;SELECT constraint_name, min, max FROM gpkg_data_column_constraints WHERE constraint_type = 'range'&quot;);</span>
    			) {
    		// 2
<span class="pc bpc" id="L390" title="1 of 2 branches missed.">    		while (resultSet1.next()) {</span>
<span class="nc" id="L391">    			final String constraintName = resultSet1.getString(&quot;constraint_name&quot;);</span>
    			// 3a
<span class="nc" id="L393">    			final double min = resultSet1.getDouble(&quot;min&quot;);</span>
<span class="nc bnc" id="L394" title="All 2 branches missed.">    			Assert.assertTrue(!resultSet1.wasNull(), ErrorMessage.format(ErrorMessageKeys.CONSTRAINT_MINMAX_INVALID, constraintName));</span>
    			// 3b
<span class="nc" id="L396">    			final double max = resultSet1.getDouble(&quot;max&quot;);</span>
<span class="nc bnc" id="L397" title="All 2 branches missed.">    			Assert.assertTrue(!resultSet1.wasNull(), ErrorMessage.format(ErrorMessageKeys.CONSTRAINT_MINMAX_INVALID, constraintName));</span>
    			// 3c
<span class="nc bnc" id="L399" title="All 2 branches missed.">    			Assert.assertTrue(min &lt;= max, ErrorMessage.format(ErrorMessageKeys.CONSTRAINT_MINMAX_INVALID, constraintName));</span>
<span class="nc" id="L400">    		}    		</span>
<span class="pc bpc" id="L401" title="10 of 16 branches missed.">    	}</span>
<span class="fc" id="L402">    }</span>

    /**
     * If the `gpkg_data_column_constraints` table contains rows with 
     * `constraint_type` column values of &quot;range&quot;, the `min_is_inclusive` and 
     * `max_is_inclusive` column values for those rows SHALL be 0 or 1.
     * 
     * @see &lt;a href=&quot;http://www.geopackage.org/spec/#r112&quot; target=
     *      &quot;_blank&quot;&gt;F.9. Schema - Requirement 112&lt;/a&gt;
     *
     * @throws SQLException
     *             If an SQL query causes an error
     */
    @Test(description = &quot;See OGC 12-128r13: Requirement 112&quot;)
    public void dataColumnConstraintsInclusive() throws SQLException
    {
<span class="pc" id="L418">    	try (</span>
    	    	// 1
<span class="fc" id="L420">    			final Statement statement1 = this.databaseConnection.createStatement();</span>

<span class="fc" id="L422">    			final ResultSet resultSet1 = statement1.executeQuery(String.format(&quot;SELECT constraint_name, %s, %s FROM gpkg_data_column_constraints WHERE constraint_type = 'range'&quot;, minIsInclusive, maxIsInclusive));</span>
    			) {
    		// 2
<span class="pc bpc" id="L425" title="1 of 2 branches missed.">    		while (resultSet1.next()) {</span>
<span class="nc" id="L426">    			final String constraintName = resultSet1.getString(&quot;constraint_name&quot;);</span>
    			// 3
<span class="nc" id="L428">    			resultSet1.getBoolean(minIsInclusive);</span>
<span class="nc bnc" id="L429" title="All 2 branches missed.">    			Assert.assertTrue(!resultSet1.wasNull(), ErrorMessage.format(ErrorMessageKeys.CONSTRAINT_INCLUSIVE_INVALID, constraintName));</span>
<span class="nc" id="L430">    			resultSet1.getBoolean(maxIsInclusive);</span>
<span class="nc bnc" id="L431" title="All 2 branches missed.">    			Assert.assertTrue(!resultSet1.wasNull(), ErrorMessage.format(ErrorMessageKeys.CONSTRAINT_INCLUSIVE_INVALID, constraintName));</span>
<span class="nc" id="L432">    		}</span>
<span class="pc bpc" id="L433" title="10 of 16 branches missed.">    	}</span>
<span class="fc" id="L434">    }</span>

    /**
     * If the `gpkg_data_column_constraints` table contains rows with 
     * `constraint_type` column values of &quot;enum&quot; or &quot;glob&quot;, the `min`, `max`, 
     * `min_is_inclusive` and `max_is_inclusive` column values for those rows 
     * SHALL be NULL.
     * 
     * @see &lt;a href=&quot;http://www.geopackage.org/spec/#r113&quot; target=
     *      &quot;_blank&quot;&gt;F.9. Schema - Requirement 113&lt;/a&gt;
     *
     * @throws SQLException
     *             If an SQL query causes an error
     */
    @Test(description = &quot;See OGC 12-128r13: Requirement 113&quot;)
    public void dataColumnConstraintsGlobMinMax() throws SQLException {
<span class="pc" id="L450">    	try (</span>
    	    	// 1
<span class="fc" id="L452">    			final Statement statement1 = this.databaseConnection.createStatement();</span>

<span class="fc" id="L454">    			final ResultSet resultSet1 = statement1.executeQuery(String.format(&quot;SELECT constraint_name, min, max, %s, %s FROM gpkg_data_column_constraints WHERE constraint_type IN ('enum','glob')&quot;, minIsInclusive, maxIsInclusive));</span>
    			) {
    		// 2
<span class="pc bpc" id="L457" title="1 of 2 branches missed.">    		while (resultSet1.next()) {</span>
<span class="nc" id="L458">    			final String constraintName = resultSet1.getString(&quot;constraint_name&quot;);</span>
    			// 3a
<span class="nc" id="L460">    			resultSet1.getDouble(&quot;min&quot;);</span>
<span class="nc" id="L461">    			Assert.assertTrue(resultSet1.wasNull(), </span>
<span class="nc" id="L462">    					ErrorMessage.format(ErrorMessageKeys.CONSTRAINT_MINMAX_INVALID, constraintName));</span>
    			// 3b
<span class="nc" id="L464">    			resultSet1.getDouble(&quot;max&quot;);</span>
<span class="nc" id="L465">    			Assert.assertTrue(resultSet1.wasNull(), </span>
<span class="nc" id="L466">    					ErrorMessage.format(ErrorMessageKeys.CONSTRAINT_MINMAX_INVALID, constraintName));</span>
    			// 3c
<span class="nc" id="L468">    			resultSet1.getDouble(minIsInclusive);</span>
<span class="nc" id="L469">    			Assert.assertTrue(resultSet1.wasNull(), </span>
<span class="nc" id="L470">    					ErrorMessage.format(ErrorMessageKeys.CONSTRAINT_INCLUSIVE_INVALID, constraintName));</span>
    			// 3d
<span class="nc" id="L472">    			resultSet1.getDouble(maxIsInclusive);</span>
<span class="nc" id="L473">    			Assert.assertTrue(resultSet1.wasNull(), </span>
<span class="nc" id="L474">    					ErrorMessage.format(ErrorMessageKeys.CONSTRAINT_INCLUSIVE_INVALID, constraintName));</span>
<span class="nc" id="L475">    		}    		</span>
<span class="pc bpc" id="L476" title="10 of 16 branches missed.">    	}</span>
<span class="fc" id="L477">    }</span>

    /**
     * If the `gpkg_data_column_constraints` table contains rows with 
     * `constraint_type` column values of &quot;enum&quot; or &quot;glob&quot;, the `value` 
     * column SHALL NOT be NULL.
     * 
     * @see &lt;a href=&quot;http://www.geopackage.org/spec/#r114&quot; target=
     *      &quot;_blank&quot;&gt;F.9. Schema - Requirement 114&lt;/a&gt;
     *
     * @throws SQLException
     *             If an SQL query causes an error
     */
    @Test(description = &quot;See OGC 12-128r13: Requirement 114&quot;)
    public void dataColumnConstraintsGlobValue() throws SQLException {
<span class="pc" id="L492">    	try (</span>
    	    	// 1
<span class="fc" id="L494">    			final Statement statement1 = this.databaseConnection.createStatement();</span>

<span class="fc" id="L496">    			final ResultSet resultSet1 = statement1.executeQuery(&quot;SELECT constraint_name, value FROM gpkg_data_column_constraints WHERE constraint_type IN ('enum','glob')&quot;);</span>
    			) {
    		// 2
<span class="pc bpc" id="L499" title="1 of 2 branches missed.">    		while (resultSet1.next()) {</span>
    			// 3
<span class="nc" id="L501">    			final String constraintName = resultSet1.getString(&quot;constraint_name&quot;);</span>
<span class="nc" id="L502">    			resultSet1.getString(&quot;value&quot;);</span>

<span class="nc bnc" id="L504" title="All 2 branches missed.">    			Assert.assertTrue(!resultSet1.wasNull(), </span>
<span class="nc" id="L505">    					ErrorMessage.format(ErrorMessageKeys.CONSTRAINT_NON_NULL_VALUE, constraintName, &quot;not&quot;));</span>
<span class="nc" id="L506">    		}    		</span>
<span class="pc bpc" id="L507" title="10 of 16 branches missed.">    	} </span>
<span class="fc" id="L508">    }</span>
<span class="fc" id="L509">    static private List&lt;String&gt; AllowedConstraintTypes = Arrays.asList(&quot;range&quot;, &quot;enum&quot;, &quot;glob&quot;);</span>
    private String maxIsInclusive;
    private String minIsInclusive;
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>