<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>FeaturesTests.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoPackage 1.2 Conformance Test Suite</a> &gt; <a href="index.source.html" class="el_package">org.opengis.cite.gpkg12.features</a> &gt; <span class="el_source">FeaturesTests.java</span></div><h1>FeaturesTests.java</h1><pre class="source lang-java linenums">package org.opengis.cite.gpkg12.features;

import static org.testng.Assert.assertTrue;
import static org.testng.AssertJUnit.fail;

import java.math.BigInteger;
import java.nio.ByteOrder;
import java.nio.charset.StandardCharsets;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import org.opengis.cite.gpkg12.ColumnDefinition;
import org.opengis.cite.gpkg12.ErrorMessage;
import org.opengis.cite.gpkg12.ErrorMessageKeys;
import org.opengis.cite.gpkg12.FeaturesFixture;
import org.opengis.cite.gpkg12.TableVerifier;
import org.opengis.cite.gpkg12.util.GeoPackageVersion;
import org.opengis.cite.gpkg12.util.DatabaseUtility;
import org.testng.Assert;
import org.testng.SkipException;
import org.testng.annotations.BeforeClass;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;

/**
 * Defines test methods that apply to descriptive information about a
 * GeoPackage's content as it pertains to features.
 *
 * &lt;p style=&quot;margin-bottom: 0.5em&quot;&gt;
 * &lt;strong&gt;Sources&lt;/strong&gt;
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;&lt;a href=&quot;http://www.geopackage.org/spec/#features&quot; target= &quot;_blank&quot;&gt;
 * GeoPackage Encoding Standard - 2.1 Features&lt;/a&gt; (OGC 12-128r13) and OGC 12-128r14 &lt;/li&gt;
 * &lt;/ul&gt;
 *
 * @author Jeff Yutzler
 */
<span class="fc" id="L48">public class FeaturesTests extends FeaturesFixture {</span>

	    // --------------------- Private Class Variables -----------------
<span class="fc" id="L51">		private final Boolean NativeOrderIsBE = ByteOrder.nativeOrder().equals(ByteOrder.BIG_ENDIAN);</span>
    
		private static final Map&lt;String, ColumnDefinition&gt; FeatureTableExpectedColumns; 
		private static final Map&lt;String, List&lt;String&gt;&gt; GeometrySubtypesAllowed; 
		
		// These flags can be set once and then used to quickly skip tests that depend on these two things
		private boolean hasGeometryColumnsTable;
		private boolean hasGPKGExtensionsTable;

	
<span class="fc" id="L61">		private final Collection&lt;String&gt; possibleFeatureTableNames         = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L62">		private final Collection&lt;String&gt; featureTableNames = new ArrayList&lt;&gt;();</span>

		
	
		// For tests 19, 20, 32, 33, 19b, 67, 78 - they will all be run based on an iterator and we need the error reporting to be capped,
		// hence these counters and limits are defined to cap those error reports.
<span class="fc" id="L68">		 int errorDetected19 = 0;</span>
<span class="fc" id="L69">		 int errorDetected32 = 0;</span>
<span class="fc" id="L70">		 int errorDetected33 = 0;</span>
<span class="fc" id="L71">		 int errorDetectedNSG19b = 0;</span>
<span class="fc" id="L72">		 int errorDetected66 = 0;</span>
<span class="fc" id="L73">		 int errorDetected67 = 0;</span>
<span class="fc" id="L74">		 int errorDetected78 = 0;</span>
<span class="fc" id="L75">		 int errorDetected20 = 0 ;</span>
		 
		// Since a feature typically will have all instances reporting the same errors, this maximum count reduces the reporting per feature.
		private static final int maxErrorsToReport19 = 15;           // This is a per feature maximum report. This test has several different things going on.
																	 // and it should be split into sub items to better report these issues.
		private static final int maxErrorsToReport32 = 5;            // Per feature maximum, this test reports one issue - but it'll list all instances found
		private static final int maxErrorsToReport33 = 5;            // Per feature maximum, this test reports one issue - but it'll list all instances found
//		private static final int maxErrorsToReportNSG19b = 5;
		private static final int maxErrorsToReport66 = 5;
		private static final int maxErrorsToReport67 = 5;
		private static final int maxErrorsToReport78 = 5;
		private static final int maxErrorsToReport20 = 5;
		
		// Masks and starting byte index for Geometry BLOB Contents
//		private static final byte magicB0 = 0x47;
//		private static final byte magicB1 = 0x50;
		private static final byte maskFlagBinaryType = 0x20;
		private static final int  shiftFlagBinaryType = 5;
		private static final byte maskFlagEmptyGeometry = 0x10;
		private static final int  shiftFlagEmptyGeometry = 4;
		private static final byte maskFlagEnvelope = 0x0E;
		private static final int  shiftFlagEnvelope = 1;
		private static final byte maskFlagHeaderEndian = 0x01;
		private static final int  startOfVersion = 2;
		private static final int  startOfFlags = 3;
		private static final int  startOfSRIDIndex = 4;
		private static final int  startOfEnvelopeIndex = 8;
		private static final int  startOfGeometryType = 1;
//		private static final int  startOfEnvelopeCodeIndex = 3;
		private static final int maximumEnvelopeSize = 8 * Double.BYTES;  // As per the OGC spec, no more than 8 doubles should be in the envelope
		
	    private static final String myminx = &quot;minx&quot;;
	    private static final String myminy = &quot;miny&quot;;
	    private static final String mymaxx = &quot;maxx&quot;;
	    private static final String mymaxy = &quot;maxy&quot;;
	    private static final String myminz = &quot;minz&quot;;
	    private static final String mymaxz = &quot;maxz&quot;;
	    private static final String myminm = &quot;minm&quot;;
	    private static final String mymaxm = &quot;maxm&quot;;

	    
	    private static final String geomCIRCULARSTRING = &quot;CIRCULARSTRING&quot;;
	    private static final String geomCOMPOUNDCURVE = &quot;COMPOUNDCURVE&quot;;
	    private static final String geomCURVEPOLYGON = &quot;CURVEPOLYGON&quot;;
	    private static final String geomMULTICURVE = &quot;MULTICURVE&quot;;
	    private static final String geomMULTISURFACE = &quot;MULTISURFACE&quot;;
	    private static final String geomCURVE = &quot;CURVE&quot;;
	    private static final String geomSURFACE = &quot;SURFACE&quot;;
	    private static final String geomUNSUPPORTED = &quot;UNSUPPORTED&quot;;
	    
		// From Annex G: These are in a &quot;Note&quot; under table 28
		   // GEOMETRY subtypes are POINT, CURVE, SURFACE and GEOMCOLLECTION  &lt;-- assume they must mean GEOMETRYCOLLECTION because GEOMCOLLECTION is not a geometry type
		   // CURVE subtypes are LINESTRING, CIRCULARSTRING and COMPOUNDCURVE
		   // SURFACE subtype is CURVEPOLYGON
		   // CURVEPOLYGON subtype is POLYGON
		   // GEOMETRYCOLLECTION subtypes are MULTIPOINT, MULTICURVE and MULTISURFACE
		   // MULTICURVE subtype is MULTILINESTRING  &lt;- contradicted in 2.1.1
		   // MULTISURFACE subtype is MULTIPOLYGON   &lt;- contradicted in 2.1.1
		
		// Assumption that subtypes of subtypes are also allowed
		// This static hasmap defines for each supertype, all of the allowed subtype geometries.
	    // TODO this section needs work. There are inconsistencies in the spec and the test requirement isn't very specific
		 static
		 {
<span class="fc" id="L139">			 GeometrySubtypesAllowed = new HashMap&lt;&gt;();</span>
<span class="fc" id="L140">			 GeometrySubtypesAllowed.put(geomCURVE,  Arrays.asList(geomLINESTRING, geomCIRCULARSTRING, geomCOMPOUNDCURVE              // Subtypes</span>
					));
			 
<span class="fc" id="L143">			 GeometrySubtypesAllowed.put(geomSURFACE,  Arrays.asList(geomCURVEPOLYGON,                                              // Subtypes</span>
					 geomPOLYGON));   // Polygon is a subtype of a subtype
			 
<span class="fc" id="L146">			 GeometrySubtypesAllowed.put(geomCURVEPOLYGON,  Arrays.asList(geomPOLYGON,                                              // Subtypes</span>
					 geomCURVE, geomLINESTRING, geomCIRCULARSTRING, geomCOMPOUNDCURVE));

			 // 2.1.1 Polygon: A restricted form of CurvePolygon where each ring is defined as a simple, closed LineString.
<span class="fc" id="L150">			 GeometrySubtypesAllowed.put(geomPOLYGON,  Arrays.asList(geomLINESTRING</span>
					 ));
			 
<span class="fc" id="L153">			 GeometrySubtypesAllowed.put(geomGEOMETRYCOLLECTION,  Arrays.asList(geomMULTIPOINT, geomMULTICURVE, geomMULTISURFACE,       // Subtypes</span>
					 geomMULTIPOLYGON, geomMULTILINESTRING));  // Multipolygon is a subtype of a subtype and Multilinestring is subtype of a subtype
			 
			 
			 // 2.1.1 MultiSurface: A restricted form of GeometryCollection where each Geometry in the collection must be of type Surface.
<span class="fc" id="L158">			 GeometrySubtypesAllowed.put(geomMULTISURFACE,  Arrays.asList(geomSURFACE     ));  </span>

			 // 2.1.1 MultiPolygon: A restricted form of MultiSurface where each Surface in the collection must be of type Polygon.
<span class="fc" id="L161">			 GeometrySubtypesAllowed.put(geomMULTIPOLYGON,  Arrays.asList(geomPOLYGON   ));    </span>
			 
			 // 2.1.1 MultiCurve: A restricted form of GeometryCollection where each Geometry in the collection must be of type Curve
<span class="fc" id="L164">			 GeometrySubtypesAllowed.put(geomMULTICURVE,  Arrays.asList( geomCURVE  ));   </span>
			 
			 // 2.1.1 MultiLineString: A restricted form of MultiCurve where each Curve in the collection must be of type LineString.
<span class="fc" id="L167">			 GeometrySubtypesAllowed.put(geomMULTILINESTRING,  Arrays.asList(geomLINESTRING ));  </span>

			 // 2.1.1 ???
<span class="fc" id="L170">			 GeometrySubtypesAllowed.put(geomMULTIPOINT,  Arrays.asList(geomPOINT ));  </span>
			 
<span class="fc" id="L172">			 GeometrySubtypesAllowed.put(geomGEOMETRY,  Arrays.asList(geomPOINT, geomCURVE, geomSURFACE, geomGEOMETRYCOLLECTION,          // Subtypes</span>
					 geomLINESTRING, geomCIRCULARSTRING, geomCOMPOUNDCURVE, geomCURVEPOLYGON, geomPOLYGON,  geomMULTIPOINT, geomMULTICURVE, geomMULTISURFACE, geomMULTIPOLYGON, geomMULTILINESTRING));
		 }
	
		 // Define the required columns of the feature table
		static
		{
<span class="fc" id="L179">			FeatureTableExpectedColumns = new HashMap&lt;&gt;();</span>
<span class="fc" id="L180">			FeatureTableExpectedColumns.put(&quot;id&quot;,           new ColumnDefinition(&quot;INTEGER&quot;, false, true,  true,  null));</span>
<span class="fc" id="L181">			FeatureTableExpectedColumns.put(&quot;geometry&quot;,    new ColumnDefinition(&quot;GEOMETRY&quot;, true,  false, false, null));</span>
<span class="fc" id="L182">		}</span>
		
		// End Private Class Information
		

	/**
	 * Sets up variables used across methods
	 *
	 * @throws SQLException
	 *             if there is a database error
	 */
	@BeforeClass
	public void setUp() throws SQLException {

		// Set internal flag denoting whether the geopackage has geometry columns table or not. If it does not, then many tests will be skipped.
<span class="fc" id="L197">    	this.hasGeometryColumnsTable = DatabaseUtility.doesTableOrViewExist(this.databaseConnection, &quot;gpkg_geometry_columns&quot;);</span>
<span class="fc" id="L198">    	this.hasGPKGExtensionsTable = DatabaseUtility.doesTableOrViewExist(this.databaseConnection, &quot;gpkg_extensions&quot;);</span>

    	// Capture any **potential** feature table names that are **NOT** listed within the gpkg_contents
    	// Save these names as we will compare them later on to the names specified in the gpkg_contents.
    	
<span class="pc" id="L203">        try(Statement statement = this.databaseConnection.createStatement();</span>
<span class="fc" id="L204">            ResultSet resultSet = statement.executeQuery(&quot;SELECT tbl_name FROM sqlite_master WHERE tbl_name NOT LIKE \'gpkg_%\' AND (type = \'tile\' OR type = \'view\');&quot;))</span>
        {
<span class="fc bfc" id="L206" title="All 2 branches covered.">            while(resultSet.next())</span>
            {
            	// Examine each of the potential feature tables in the geopackage to see if they are missing from the
            	// contents specification. This test is not specifically identified in the standard.
                try
                {
<span class="fc" id="L212">                    final String tableName = resultSet.getString(&quot;tbl_name&quot;);</span>

                    // If we think we have a feature table, make sure it has the expected columns.
                    // This throws if the table definition doesn't match, and won't be added to the collection
<span class="nc" id="L216">                    TableVerifier.verifyTable(this.databaseConnection,</span>
                                              tableName,
                                              FeatureTableExpectedColumns,
                                              null,
                                              null);
                    // Save the feature table on a list so that we may use it later on.
<span class="nc" id="L222">                    this.possibleFeatureTableNames.add(tableName);</span>
                }
<span class="fc" id="L224">                catch(final Throwable ignore)</span>
                {
                    // If verification fails- it's not a features table and we don't care about it so ignore

<span class="pc" id="L228">                }</span>
            }
<span class="pc bpc" id="L230" title="12 of 16 branches missed.">		}</span>
		

<span class="pc" id="L233">		try (</span>
<span class="fc" id="L234">				final Statement statement = this.databaseConnection.createStatement();</span>
<span class="fc" id="L235">				final ResultSet resultSet = statement.executeQuery(&quot;SELECT table_name FROM gpkg_contents WHERE data_type = \'features\';&quot;);</span>
				) {
<span class="fc bfc" id="L237" title="All 2 branches covered.">			while (resultSet.next()) {</span>
<span class="fc" id="L238">				this.featureTableNames.add(resultSet.getString(1));</span>
			}
<span class="pc bpc" id="L240" title="12 of 16 branches missed.">		}</span>


<span class="fc bfc" id="L243" title="All 2 branches covered.">		Assert.assertTrue(!this.featureTableNames.isEmpty(), ErrorMessage.format(ErrorMessageKeys.CONFORMANCE_CLASS_NOT_USED, getTestName()));</span>
<span class="fc" id="L244">	}</span>


	
    
    /**
     * A DataProvider that supplies feature instance test methods with content from gpkg_geometry_columns
     * such that feature instance test methods may verify feature internal content is consistent with
     * gpkg_geometry_columns information.
     * 
     * @return An Iterator over an array containing a set of objects representing
     *         the information needed to process tests against geometry BLOB information
     */
    @DataProvider(name = &quot;feature-geometry-information&quot;)
    public Iterator&lt;Object[]&gt; getFeaturesWithGeometryInfo() {
<span class="fc" id="L259">    	List&lt;Object[]&gt; data = new ArrayList&lt;Object[]&gt;();</span>
        
    	/*
		 * 1. SELECT table_name AS tn, column_name AS cn FROM gpkg_geometry_columns WHERE table_name IN (SELECT table_name FROM gpkg_contents WHERE data_type = ‘features’)
		 *    added srs_id, geometry_type_name, z, m in order to capture the remaining testable values in gpkg_geometry_columns for which we will visit every feature instance.
		 */
<span class="pc" id="L265">        try(final Statement statement = this.databaseConnection.createStatement();</span>
<span class="fc" id="L266">                final ResultSet resultSet = statement.executeQuery(&quot;SELECT table_name AS tn, column_name AS cn, srs_id, geometry_type_name AS gt_name, z as z_flag, m as m_flag FROM gpkg_geometry_columns WHERE table_name IN (SELECT table_name FROM gpkg_contents WHERE data_type = \'features\');&quot;))</span>
        {
<span class="fc bfc" id="L268" title="All 2 branches covered.">            while(resultSet.next())</span>
            {
  				/* Package the parameters:
  				*  String TableName
  				* String GeometryColumnName gpkg_geometry_columns
  				* String GeometryType from gpkg_geometry_columns
  				* Integer SRS id from gpkg_geometry_columns
  				* byte Z flag from gpkg_geometry_columns
  				* byte M flag from gpkg_geometry_columns
  				*/

<span class="fc" id="L279">  	        	Object[] tuple = {resultSet.getString(&quot;tn&quot;), 						</span>
<span class="fc" id="L280">  	        			resultSet.getString(&quot;cn&quot;), 						</span>
<span class="fc" id="L281">  	        			resultSet.getString(&quot;gt_name&quot;).toUpperCase(),</span>
<span class="fc" id="L282">  	        			resultSet.getInt(&quot;srs_id&quot;), </span>
<span class="fc" id="L283">  	        			(byte) resultSet.getInt(&quot;z_flag&quot;), </span>
<span class="fc" id="L284">  	        			(byte) resultSet.getInt(&quot;m_flag&quot;)</span>
  	        	}; 
<span class="fc" id="L286">  	        	data.add(tuple);</span>
<span class="fc" id="L287">  			}</span>
                  	
<span class="pc bpc" id="L289" title="12 of 16 branches missed.">        } catch (SQLException e) {</span>
    		// TODO Auto-generated catch block
<span class="nc" id="L291">    		e.printStackTrace();</span>
<span class="fc" id="L292">    	}        </span>

<span class="fc" id="L294">        return data.iterator();</span>
    }


	/**
	 * Test case
	 * /base/core/contents/data/table_def/srs_id
	 *
	 * @see &lt;a href=&quot;http://www.geopackage.org/spec120/index.html&quot; target=
	 * &quot;_blank&quot;&gt;Contents - Requirement 13&lt;/a&gt;
	 *
	 * @throws SQLException
	 *             If an SQL query causes an error
	 */
    @Test(description = &quot;See OGC 12-128r14: Requirement 13 srs_id&quot;)
    public void featureSRSconsistency() throws SQLException {

    	// This requirement is not currently called out under the TEST req area,
    	// but it is defined within Requirement 13 and not currently tested under
    	// the requirement 13 test code.
    	//
    	// Spatial Reference System ID:
    	// gpkg_spatial_ref_sys.srs_id; when data_type is features, SHALL also match
    	// gpkg_geometry_columns.srs_id; 


<span class="fc" id="L320">		int gpkgGeomCount = 0;</span>
<span class="fc" id="L321">		int gpkgContentCount = 0;</span>
<span class="fc" id="L322">		int gpkgAndContentCount = 0;</span>
<span class="pc" id="L323">		try (</span>
<span class="fc" id="L324">				final Statement statement2 = this.databaseConnection.createStatement();</span>
<span class="fc" id="L325">				final ResultSet resultSet2 = statement2.executeQuery(</span>
<span class="fc" id="L326">						String.format(&quot;SELECT count(*) as ggcCount FROM \'gpkg_geometry_columns\';&quot;));</span>
				) {
<span class="fc" id="L328">			gpkgGeomCount = resultSet2.getInt(&quot;ggcCount&quot;);</span>
<span class="pc bpc" id="L329" title="12 of 16 branches missed.">		}</span>
<span class="pc" id="L330">		try (</span>
<span class="fc" id="L331">				final Statement statement2 = this.databaseConnection.createStatement();</span>
<span class="fc" id="L332">				final ResultSet resultSet2 = statement2.executeQuery(</span>
<span class="fc" id="L333">						String.format(&quot;SELECT count(*) as ggcCount FROM \'gpkg_contents\' WHERE data_type = \'features\';&quot;));</span>
				) {
<span class="fc" id="L335">			gpkgContentCount = resultSet2.getInt(&quot;ggcCount&quot;);</span>
<span class="pc bpc" id="L336" title="12 of 16 branches missed.">		}</span>
<span class="pc" id="L337">		try (</span>
<span class="fc" id="L338">				final Statement statement2 = this.databaseConnection.createStatement();</span>
<span class="fc" id="L339">				final ResultSet resultSet2 = statement2.executeQuery(</span>
<span class="fc" id="L340">						String.format(</span>
				&quot;SELECT count(*) as ggcCount FROM \'gpkg_contents\' INNER JOIN \'gpkg_geometry_columns\' ON ((gpkg_contents.srs_id = gpkg_geometry_columns.srs_id) AND (gpkg_contents.table_name = gpkg_geometry_columns.table_name));&quot;));
				) {
<span class="fc" id="L343">			gpkgAndContentCount = resultSet2.getInt(&quot;ggcCount&quot;);</span>
<span class="pc bpc" id="L344" title="12 of 16 branches missed.">		}</span>
		// If the geopackage geometry columns count is not the same as the geopackage content count (for features), then we have a problem.
<span class="pc bpc" id="L346" title="1 of 2 branches missed.">		if (gpkgGeomCount != gpkgContentCount) {</span>
<span class="nc" id="L347">			Assert.assertTrue(false,</span>
<span class="nc" id="L348">					ErrorMessage.format(ErrorMessageKeys.FEATURE_GEOMETRY_COLUMNS_DOES_NOT_MATCH_CONTENTS_COUNT));</span>
		// If we got a different count when looking at common feature names and srs_id values, then the test for requirement 13 fails
<span class="pc bpc" id="L350" title="2 of 4 branches missed.">		} else if (gpkgGeomCount != gpkgAndContentCount || gpkgContentCount != gpkgAndContentCount) {</span>
<span class="nc" id="L351">			Assert.assertTrue(false,</span>
<span class="nc" id="L352">					ErrorMessage.format(ErrorMessageKeys.FEATURE_GEOMETRY_COLUMNS_SRS_ID_NOT_CONSISTENT_WITH_CONTENTS));</span>
		}	

<span class="fc" id="L355">    }	</span>
	

    /**
     * Verify that the gpkg_contents table_name value table exists, and is apparently a feature table for every row with a data_type column value of 'features'
     *
     * Test Case
     * {@code /opt/features/contents/data/features_row}
     * @see &lt;a href=&quot;http://www.geopackage.org/spec120/index.html&quot; target=
     *            &quot;_blank&quot;&gt;Vector Features - Requirement 18&lt;/a&gt;
     *            
     * 
     * @throws SQLException
     *                If an SQL query causes an error
     */
	@Test( description = &quot;See OGC 12-128r14: Requirement 18&quot;)
	public void features_contents_data_features_row() throws SQLException
	{
		/*
		 *  TEST METHOD
		* 1.  Execute test&lt;br&gt;/opt/features/vector_features/data/feature_table_integer_primary_key
		*/
<span class="fc" id="L377">		final Collection&lt;String&gt; missingFeatureTableNames = this.possibleFeatureTableNames</span>
<span class="fc" id="L378">				.stream()</span>
<span class="pc bnc" id="L379" title="All 2 branches missed.">				.filter(tableName -&gt; !this.featureTableNames.contains(tableName))</span>
<span class="fc" id="L380">				.collect(Collectors.toList());</span>

<span class="fc" id="L382">	   final String reportOut = String.join(&quot;, &quot;, missingFeatureTableNames);</span>
<span class="pc bpc" id="L383" title="2 of 4 branches missed.">	   Assert.assertTrue((missingFeatureTableNames == null || missingFeatureTableNames.isEmpty()),</span>
<span class="fc" id="L384">			   ErrorMessage.format(ErrorMessageKeys.FEATURE_TABLE_NAMES_MISSING,</span>
					   reportOut));

<span class="fc" id="L387">	}</span>
	

     
 
	 

	/**
	 * A GeoPackage MAY contain tables or updateable views containing vector 
	 * features. Every such feature table or view in a GeoPackage SHALL have 
	 * a column with column type INTEGER and PRIMARY KEY AUTOINCREMENT column 
	 * constraints per EXAMPLE : Sample Feature Table or View Definition and 
	 * sample_feature_table Table Definition SQL (Informative).
	 *
	 * Test case
	 * {@code /opt/features/vector_features/data/feature_table_integer_primary_key}
	 *
	 * @see &lt;a href=&quot;requirement_feature_integer_pk&quot; target= &quot;_blank&quot;&gt;Vector
	 *      Features User Data Tables - Requirement 29&lt;/a&gt;
	 *
	 * @throws SQLException
	 *             If an SQL query causes an error
	 */
	@Test(description = &quot;See OGC 12-128r13: Requirement 29&quot;)
	public void featureTableIntegerPrimaryKey() throws SQLException {
		// 1
<span class="fc bfc" id="L413" title="All 2 branches covered.">		for (final String tableName : this.featureTableNames) {</span>
<span class="pc" id="L414">			try (</span>
<span class="fc" id="L415">					final Statement statement = this.databaseConnection.createStatement();</span>
					// 3a
<span class="fc" id="L417">					final ResultSet resultSet = statement.executeQuery(String.format(&quot;PRAGMA table_info(\'%s\');&quot;, tableName));</span>
					) {
				// 3b
<span class="fc" id="L420">				assertTrue(resultSet.next(),</span>
<span class="fc" id="L421">						ErrorMessage.format(ErrorMessageKeys.MISSING_TABLE, tableName));				</span>
<span class="pc bpc" id="L422" title="12 of 16 branches missed.">			}</span>

			// 3c/3d
<span class="fc" id="L425">			checkPrimaryKey(tableName, getPrimaryKeyColumn(tableName, false), false);</span>
<span class="fc" id="L426">		}</span>
<span class="fc" id="L427">	}</span>


	
    /**
     * Verify that geometries stored in feature table geometry columns are encoded in the StandardGeoPackageBinary format.
     * and are consistent with the information specified in the gpkg_geometry_columns table for the feature type.
     * Also verify that the geometry information is consistent with other elements of the geopackage as per
     * specified test requirements. In order to optimize processing as much as possible, all tests involving
     * the feature instance geometry element are performed within this block. 
     * The entry to this test is via an iterator operating on each feature table - hence the test reports will
     * be specific to each feature table processed.
     *
     * Test Case for tests 19, 20, 32, 33, 66 (partial) 67, 78
     * {@code /opt/features/geometry_encoding/data/blob 
     * /opt/features/geometry_encoding/data/core_types_existing_sparse_data 
     * /opt/features/vector_features/data/data_values_geometry_type
     *  /opt/features/vector_features/data/data_value_geometry_srs_id
     *  /extensions/geometry_types/extension_name
     *  /reg_ext/features/spatial_indexes/implementation/sql_functions}
     * 
     * 
     * @see &lt;a href=&quot;http://www.geopackage.org/spec120/index.html&quot; target=
     *            &quot;_blank&quot;&gt;Geometry Encoding - Requirements 19, 20, 32, 33, 66 (partial), 67, 78 and Geometry Extents check (NSG 19B)&lt;/a&gt;
     *  
     * @param thisTableName 	The feature table name being processed
     * @param thisColumnName   The feature column name (the geometry column) being processed; as specified in the gpkg_geometry_columns entry table associated with this feature
     * @param geomType			The geometry type as specified in the gpkg_geometry_columns entry table associated with this feature
     * @param srs_id			The srs identifier as specified in the gpkg_geometry_columns entry table associated with this feature
     * @param z_flag			The z flag as specified in the gpkg_geometry_columns entry table associated with this feature
     * @param m_flag			The m flag as specified in the gpkg_geometry_columns entry table associated with this feature
     * 
     * @throws SQLException
     *                If an SQL query causes an error
     */
    @Test( description = &quot;See OGC 12-128r14: Requirements 19, 20, 32, 33, 66 (partial), 67, 78; and NSG Requirement 19B&quot;, dataProvider = &quot;feature-geometry-information&quot;)
    public void featureGeometryEncodingTesting(String thisTableName, String thisColumnName, String geomType, 
   		 Integer srs_id, byte z_flag, byte m_flag) throws SQLException
    {

    	try {

    		/*
    		 * 1. SELECT table_name AS tn, column_name AS cn FROM gpkg_geometry_columns WHERE table_name IN (SELECT table_name FROM gpkg_contents WHERE data_type = ‘features’)
    		 * 2. Not testable if returns an empty result set
    		 * 3. For each row from step 1
    		 */
<span class="pc" id="L474">    		try( final Statement statementInternal = this.databaseConnection.createStatement();</span>
<span class="fc" id="L475">    				final ResultSet resultSetInternal = statementInternal.executeQuery(String.format(&quot;SELECT rowid, %s as geom FROM \'%s\';&quot;, thisColumnName, thisTableName)))</span>
    		{
    			/* a. SELECT cn FROM tn
    			 * b. Not testable if none found
    			 */

    			// quick fix for https://github.com/opengeospatial/ets-gpkg12/issues/74
				//while(resultSetInternal.next() )
<span class="fc bfc" id="L483" title="All 2 branches covered.">    			if(resultSetInternal.next() )</span>
    			{
    				// The SQL should give us a numeric identifier and a geometry blob.  All of the tests in this series operate off
    				// of these two values and the parameters passed in by the iterator.
<span class="fc" id="L487">    				final long rowID = (long) resultSetInternal.getLong(1);</span>
<span class="fc" id="L488">    				final byte[] bytes = resultSetInternal.getBytes(&quot;geom&quot;);</span>

    				// We must allow for null geometries.
<span class="pc bpc" id="L491" title="1 of 2 branches missed.">    				if (bytes == null){</span>
    					//continue;
<span class="nc" id="L493">						throw new SkipException( &quot;No geom available.&quot; );</span>
    				}
    				// From the geometry blob, populate a few of the values that we can easily extract from the geometry
<span class="fc" id="L496">    				final byte envelopeCode = (byte) ((bytes[startOfFlags] &amp; maskFlagEnvelope) &gt;&gt; shiftFlagEnvelope);</span>
<span class="fc" id="L497">    				final byte binaryTypeFlag = (byte) ((bytes[startOfFlags] &amp; maskFlagBinaryType) &gt;&gt; shiftFlagBinaryType);</span>
<span class="fc" id="L498">    				final byte emptyGeometryFlag = (byte) ((bytes[startOfFlags] &amp; maskFlagEmptyGeometry) &gt;&gt; shiftFlagEmptyGeometry);</span>
<span class="fc" id="L499">    				final byte headerLE = (byte) (bytes[startOfFlags] &amp; maskFlagHeaderEndian);</span>

    				// variables needed by this series of tests that will be used by more than one test
<span class="fc" id="L502">    				Map&lt;String, Double&gt; envelopeVals = new HashMap&lt;&gt;();               // We will put the envelope in here in a bit</span>
<span class="fc" id="L503">    				final int envelopeSize = mygetEnvelopeByteSize(envelopeCode);     </span>
<span class="pc bpc" id="L504" title="4 of 8 branches missed.">    				final boolean swapHeaderBytes = (this.NativeOrderIsBE &amp;&amp; headerLE == 1) || (!this.NativeOrderIsBE &amp;&amp; headerLE == 0);</span>
<span class="fc" id="L505">    				boolean nanDetected = false;</span>

    				// Tests begin now

    				// ** START ************** 19 ************************ 19 ************************** 19 **************************
    				/* Requirement 19:
    				 * c. For each cn value from step a                 [ cn is essentially a BLOB - layout partly shown below ]
    				 *    i. Fail if the first two bytes of each gc are not 'GP'
    				 *    ii. Fail if gc.version_number is not 0
    				 *    iii. Fail if gc.flags.GeopackageBinary type != 0
    				 *    iv.  (Fail if cn.flags.E is 5-7)   Previously in 128r12 was:  Fail if ST_IsEmpty(cn value) = 1 
    				 *    v. *Fail if the geometry is empty but the envelope is not empty (gc.flags.envelope != 0 and envelope values are not NaN)
    				 * 4. Pass if no fails
    				 */


    				// GeoPackageBinaryHeader {
    				//  byte[2] magic = 0x4750;      // &quot;GP&quot; in ASCII
    				//  byte version;                // 0 = version 1
    				//  byte flags;                  // bit layout for flags below, note flags includes endianness for the rest of this header
    				//  int32 srs_id;
    				//  double[] envelope;           // size of this is implied by the envelope indicator code in the flags
    				//  }     
    				//
    				// flags bit layout:
    				//   7  6  5  4  3  2  1  0
    				//   R  R  X  Y  E  E  E  B
    				//
    				//    7: R: Reserved set to 0
    				//    6: R: Reserved set to 0
    				//    5: X: GeoPackage Binary Type  0=Standard, 1=Extended
    				//    4: Y: Empty Geometry Flag    0= non-empty geometry, 1=Empty Geometry  (so envelope should be empty or NaN too, test v.)
    				//    3-1: E: Envelope Indicator Code (3-bit unsigned)
    				//          0 = no envelope   0 byte envelope
    				//          1 = envelope is [minx, maxx, miny, maxy] 32 bytes envelope
    				//          2 = envelope is [minx, maxx, miny, maxy, minz, maxz] 48 bytes envelope
    				//          3 = envelope is [minx, maxx, miny, maxy, minz, maxz, minm, maxm]  64 bytes envelope
    				//          5-7 = invalid value for envelope  (test iv.)
    				//    0: B: Byte order for header values   0 = Big Endian, 1 = Little Endian
    				//
    				// The GeoPackageBinaryHeader is followed by WKB



    				try {
    					// i. Fail if the first two bytes of each gc are not &quot;GP&quot; 
<span class="fc" id="L551">    					final byte[] GP_HEADER = new String(&quot;GP&quot;)</span>
<span class="fc" id="L552">    							.getBytes(StandardCharsets.US_ASCII);</span>
<span class="pc bpc" id="L553" title="2 of 4 branches missed.">    					if  ( (bytes[0] != GP_HEADER[0]) || (bytes[1] != GP_HEADER[1]) ) {</span>
<span class="nc" id="L554">    						errorDetected19 ++;</span>
<span class="nc bnc" id="L555" title="All 2 branches missed.">    						if (errorDetected19 &lt; maxErrorsToReport19)</span>
<span class="nc" id="L556">    							Assert.assertTrue(false,</span>
<span class="nc" id="L557">    									ErrorMessage.format(ErrorMessageKeys.FEATURE_GEOMETRY_INVALID_MAGIC_NUMBER, </span>
<span class="nc" id="L558">    											thisTableName, rowID, thisColumnName, String.format(&quot;0x%02x%02x&quot;,  bytes[0], bytes[1])));</span>
    					}


    					// ii. Fail if gc.version_number is not 0
<span class="fc" id="L563">    					final byte version = (byte)bytes[startOfVersion];</span>
<span class="pc bpc" id="L564" title="1 of 2 branches missed.">    					if (version != 0) {</span>
<span class="nc" id="L565">    						errorDetected19 ++;</span>
<span class="nc bnc" id="L566" title="All 2 branches missed.">    						if (errorDetected19 &lt; maxErrorsToReport19)</span>
<span class="nc" id="L567">    							Assert.assertTrue(false,</span>
<span class="nc" id="L568">    									ErrorMessage.format(ErrorMessageKeys.FEATURE_GEOMETRY_INVALID_VERSION,</span>
<span class="nc" id="L569">    											thisTableName, rowID, thisColumnName, version));</span>
    					}

    					// iii. Fail if gc.flags.GeopackageBinary type != 0
<span class="pc bpc" id="L573" title="1 of 2 branches missed.">    					if (binaryTypeFlag != 0) {</span>
<span class="nc" id="L574">    						errorDetected19 ++;</span>
<span class="nc bnc" id="L575" title="All 2 branches missed.">    						if (errorDetected19 &lt; maxErrorsToReport19)</span>
<span class="nc" id="L576">    							Assert.assertTrue(false,</span>
<span class="nc" id="L577">    									ErrorMessage.format(ErrorMessageKeys.FEATURE_GEOMETRY_INVALID_BINARY_CODE,</span>
<span class="nc" id="L578">    											thisTableName, rowID, thisColumnName, binaryTypeFlag));</span>
    					}


    					// iv. (Fail if cn.flags.E is 5-7)  
<span class="pc bpc" id="L583" title="2 of 4 branches missed.">    					if ( envelopeCode &gt; 4 || envelopeCode &lt; 0 ) {</span>
<span class="nc" id="L584">    						errorDetected19 ++;</span>
<span class="nc bnc" id="L585" title="All 2 branches missed.">    						if (errorDetected19 &lt; maxErrorsToReport19)</span>
<span class="nc" id="L586">    							Assert.assertTrue(false,</span>
<span class="nc" id="L587">    									ErrorMessage.format(ErrorMessageKeys.FEATURE_GEOMETRY_INVALID_ENVELOPE_CODE,</span>
<span class="nc" id="L588">    											thisTableName, rowID, thisColumnName, envelopeCode));</span>
    					}  

<span class="nc" id="L591">    				} catch(final Exception th)</span>
    				{
<span class="nc" id="L593">    					fail(</span>
<span class="nc" id="L594">    							ErrorMessage.format(</span>
    									ErrorMessageKeys.FEATURE_GEOMETRY_BLOB_PROCESSING_TEST_FAILURE, 
<span class="nc" id="L596">    									String.format(&quot;Failure testing requirement 19i-iv on feature {0}&quot;, thisTableName), th.getMessage()));</span>
<span class="fc" id="L597">    				}  	</span>
    				// ** END ************** 19 i-iv ************************ 19 ************************** 19 **************************


    				// ** START **************  33 ************************  ************
    				//{@code /opt/features/vector_features/data/data_value_geometry_srs_id}
    				// description = &quot;See OGC 12-128r14: Requirement 33&quot;, dataProvider = &quot;feature-geometry-information&quot; 
    				/* 
    				 * REQUIREMENT 33
    				 * a. SELECT DISTINCT st_srid(cn) FROM tn            Note in this code, we process each row and we already performed the SELECT above to get each row
    				 * b. For each row from step a
    				 * i. Fail if returnvalue not equal to gc_srs_id
    				 * 4. Pass if no fails
    				 */

    				// Note: dependency on the value of currentSRID that we used for a different test is within this one.
    				// the SRSID extracted from the geometry BLOB will be compared to the srsContents (srs_id) retrieved from gpkg_contents

    				// Get a byte array at the correct offset for the srs_id and set up the byte array size to be the size of an integer
<span class="fc" id="L616">    				byte[] srspartID = byteArraySubset(bytes, startOfSRIDIndex, Integer.BYTES);   // 4 bytes</span>

    				// Using our helper function, get the integer from the byte array, and signify whether there is byte swapping needed
    				// We will SAVE this SRID as it is needed for a couple of tests
<span class="fc" id="L620">    				int currentSRID = getIntegerFromBytesWithPossibleSwap(srspartID, swapHeaderBytes);   // this value is needed for this test and a test in #19        		 </span>


    				// Check for possible byte swap error on this SRS ID content vs the gpkg_geometry_columns value (which was a parameter to this test).
    				// This will tell us if there is a problem with the detection
    				// of the endianness either within the geometry blob, or of the machine hardware upon which the test is being run.
    				// Since this is the ONLY place we are going to try to test the endianness, it needs to be done prior to messing
    				// with the envelope values. Hence, this is why this test is put prior to 19v.
    				try {

<span class="pc bpc" id="L630" title="1 of 2 branches missed.">    					if (currentSRID != srs_id )</span>
    					{
    						// So far, the test failed. Perform an extra test - swap the bytes and see if we get the SRID now -
    						// to see if the issue can be identified as a byte swap issue. Note, this may not work with large or negative values
    						// due to sign extension on the integer, but we will try it anyway.
<span class="nc" id="L635">    						int tempSRID = Integer.reverseBytes(currentSRID);</span>

<span class="nc bnc" id="L637" title="All 2 branches missed.">    						if (tempSRID == srs_id) {</span>
    							// It appears this may then be a byte swap issue, so report the SR ID problem and the fact it may be a byte swap issue
    							// meaning the header endianness may be incorrect or this code base is incorrect.
<span class="nc" id="L640">    							errorDetected33 ++;</span>
<span class="nc bnc" id="L641" title="All 2 branches missed.">    							if (errorDetected33 &lt; maxErrorsToReport33)</span>
<span class="nc" id="L642">    								Assert.assertTrue(false,</span>
<span class="nc" id="L643">    										ErrorMessage.format(ErrorMessageKeys.FEATURE_GEOMETRY_POSSIBLE_BYTE_SWAP_ERROR_SRS_MATCH,</span>
<span class="nc" id="L644">    												rowID, thisColumnName, currentSRID, srs_id, thisTableName));</span>
    						} else {
    							// Not able to determine if the issue is a byte swap issue, so report it as an SRS ID issue
<span class="nc" id="L647">    							errorDetected33 ++;</span>
<span class="nc bnc" id="L648" title="All 2 branches missed.">    							if (errorDetected33 &lt; maxErrorsToReport33)</span>
<span class="nc" id="L649">    								Assert.assertTrue(false,</span>
<span class="nc" id="L650">    										ErrorMessage.format(ErrorMessageKeys.FEATURE_GEOMETRY_SRS_MISMATCH,</span>
<span class="nc" id="L651">    												rowID, thisColumnName, currentSRID, srs_id, thisTableName));</span>
    						}
    					}
<span class="nc" id="L654">    				} catch(final Exception th)</span>
    				{
<span class="nc" id="L656">    					fail(</span>
<span class="nc" id="L657">    							ErrorMessage.format(</span>
    									ErrorMessageKeys.FEATURE_GEOMETRY_BLOB_PROCESSING_TEST_FAILURE, 
<span class="nc" id="L659">    									String.format(&quot;Failure testing requirement 33 part b on feature {0}&quot;, thisTableName), th.getMessage()));</span>
<span class="fc" id="L660">    				}</span>


    				// ** END *** 33 ************************  33 *************************


    				// ** START ************** 19v ************************ 19 ************************** 19 **************************
    				try {

    					// v. *Fail if the geometry is empty but the envelope is not empty (gc.flags.envelope != 0 and envelope values are not NaN)
<span class="pc bpc" id="L670" title="1 of 4 branches missed.">    					if (envelopeSize &gt; 0 &amp;&amp; envelopeSize &lt; maximumEnvelopeSize) {</span>
<span class="fc" id="L671">    						final byte bytesEnvelope[] = byteArraySubset(bytes, startOfEnvelopeIndex , envelopeSize);</span>
    						try {
    							// Ignoring the return value; we are just looking for the exception processing at this time
<span class="fc" id="L674">    							mygetEnvelope(envelopeSize, swapHeaderBytes, bytesEnvelope, envelopeVals);</span>

<span class="nc" id="L676">    						} catch(IllegalArgumentException ee)  // this should catch the indication that we a nan values in the envelope </span>
    						{
    							//final String errMsg = ee.getMessage();
<span class="nc" id="L679">    							nanDetected = true;</span>
<span class="fc" id="L680">    						}</span>


<span class="pc bpc" id="L683" title="2 of 4 branches missed.">    						if (!nanDetected &amp;&amp; emptyGeometryFlag != 0) {</span>
<span class="nc" id="L684">    							errorDetected19 ++;</span>
<span class="nc bnc" id="L685" title="All 2 branches missed.">    							if (errorDetected19 &lt; maxErrorsToReport19)</span>
<span class="nc" id="L686">    								Assert.assertTrue(false,</span>
<span class="nc" id="L687">    										ErrorMessage.format(ErrorMessageKeys.FEATURE_GEOMETRY_INVALID_DETECTED_EMPTY_GEOMETRY_FLAG_BUT_ENVELOPE_HAS_CONTENT,</span>
<span class="nc" id="L688">    												rowID, thisColumnName, thisTableName));</span>
    						}
    					}  // end if envelopeSize &gt; 0 ...   Currently it is valid to have an envelope that is 0 size. In the future, that may change if there is geometry.
    					// also we should never get an envelopeSize over the max size (as it comes from the code and a private method here) so we are not checking for that.


<span class="nc" id="L694">    				} catch(final Exception th)</span>
    				{
<span class="nc" id="L696">    					fail(</span>
<span class="nc" id="L697">    							ErrorMessage.format(</span>
    									ErrorMessageKeys.FEATURE_GEOMETRY_BLOB_PROCESSING_TEST_FAILURE, 
<span class="nc" id="L699">    									String.format(&quot;Failure testing requirement 19v on feature {0}&quot;, thisTableName), th.getMessage()));</span>
<span class="fc" id="L700">    				}</span>
    				// ** END ************** 19v ************************ 19 ************************** 19 **************************


    				// WKB Header
    				// byte    byteOrder     0 = Big Endian; 1 = Little Endian
    				// uint32  wkbGeometryType
    				// GEOMETRY
    				
<span class="fc" id="L709">    				String actualGeometryType = geomUNSUPPORTED;</span>
    				
    				// These next tests require that there be geometry
<span class="pc bpc" id="L712" title="1 of 2 branches missed.">    				if (emptyGeometryFlag == 0) {</span>

<span class="fc" id="L714">    					final int geometryStart = startOfEnvelopeIndex + envelopeSize;                                 // Find the start of the WKB Geometry Blob within the SHAPE Blob</span>
    					// The geometry WKB has yet another structure with yet another possible big / little endian setting
<span class="fc" id="L716">    					final byte geometryByteOrderLE = bytes[geometryStart];                                          // The Geometry Blob may have a different byte order than the header or the SQLite</span>
<span class="pc bpc" id="L717" title="2 of 8 branches missed.">    					final boolean swapGeometryBytes = (geometryByteOrderLE == 1 &amp;&amp; this.NativeOrderIsBE) || (geometryByteOrderLE == 0 &amp;&amp; !this.NativeOrderIsBE);</span>

    					// Get the subset of bytes representing the geometry type, 
    					// then get the geometry type integer from those bytes, 
    					// then get the geometry type string from the integer
<span class="fc" id="L722">    					byte[] geomtypeBytes = byteArraySubset(bytes, geometryStart + startOfGeometryType, Integer.BYTES);</span>
<span class="fc" id="L723">    					final int currentGeomType = getIntegerFromBytesWithPossibleSwap(geomtypeBytes, swapGeometryBytes);</span>
<span class="fc" id="L724">    					actualGeometryType = getGeomTypeFromNum(currentGeomType).toUpperCase();</span>

    					// ** START ****** 20 ************************ 20 ************************** 20 **************************
    					/* 
    					 * REQUIREMENT 20
    					 * 1.   b.  For  each row from step a, 
    					 * if bytes 2-5 of cn.wkb as uint32 in endianness of gc.wkb 
    					 * 
    					 * ***** NOTE THIS TEST SHOULD NOT be performed if there is NO geometry
    					 * 
    					 * byte 1 of cn from #1 are a geometry type value from Annex G Table 42, 
    					 * then
    					 *    i.  Log cn.header values, wkb endianness and geometry type
    					 *    
    					 *    TEST IS NOT including full decomposition of WKB, only the geometry type
    					 *   ii.  *If cn.wkb is not  correctly encoded per ISO 13249-3  clause 5.1.46  then log fail
    					 *  iii.  Otherwise log pass
    					 *  6.  Pass  if log contains pass and no fails
    					 */
    					try {

    						// Verify that the actual geometry type is something valid, our getGeomTypeFromNum will assign &quot;UNSUPPORTED&quot; if it is invalid
<span class="pc bpc" id="L746" title="1 of 2 branches missed.">    						if ( actualGeometryType.equals(geomUNSUPPORTED)) {</span>
    							// So the geometry type is not recognized. Try a byte swap on the value and see if we get any
    							// supported value now. Report a different error if we get a value.
<span class="nc bnc" id="L749" title="All 2 branches missed.">    							final int altGeomType = getIntegerFromBytesWithPossibleSwap(geomtypeBytes, !swapGeometryBytes);   // test if the byte swap flag might be wrong</span>
<span class="nc" id="L750">    							final String testGeomType = getGeomTypeFromNum(altGeomType).toUpperCase();</span>
<span class="nc bnc" id="L751" title="All 2 branches missed.">    							if (testGeomType.equals(geomUNSUPPORTED)) {</span>
<span class="nc" id="L752">	    							errorDetected20 ++;</span>
<span class="nc bnc" id="L753" title="All 2 branches missed.">	    							if (errorDetected20 &lt; maxErrorsToReport20)</span>
<span class="nc" id="L754">	    								Assert.assertTrue(false,</span>
<span class="nc" id="L755">	    										ErrorMessage.format(ErrorMessageKeys.FEATURE_GEOMETRY_TYPE_INVALID,		 </span>
<span class="nc" id="L756">	    												rowID, thisColumnName, geomType, (int)currentGeomType, thisTableName));</span>
    							} else {
    								// Report a possible byte swap problem in the WKB portion of this BLOB
<span class="nc" id="L759">	    							errorDetected20 ++;</span>
<span class="nc bnc" id="L760" title="All 2 branches missed.">	    							if (errorDetected20 &lt; maxErrorsToReport20)</span>
<span class="nc" id="L761">	    								Assert.assertTrue(false,</span>
<span class="nc" id="L762">	    										ErrorMessage.format(ErrorMessageKeys.FEATURE_GEOMETRY_TYPE_INVALID_POSSIBLE_BYTE_SWAP,		 </span>
<span class="nc" id="L763">	    												rowID, thisColumnName, geomType, (int)currentGeomType, thisTableName, (int)altGeomType, testGeomType));</span>
    							}
    						}

<span class="nc" id="L767">    					} catch(final Exception th)</span>
    					{
<span class="nc" id="L769">    						fail(</span>
<span class="nc" id="L770">    								ErrorMessage.format(</span>
    										ErrorMessageKeys.FEATURE_GEOMETRY_BLOB_PROCESSING_TEST_FAILURE, 
<span class="nc" id="L772">    										String.format(&quot;Failure testing requirement 20 on feature {0}&quot;, thisTableName), th.getMessage()));</span>
<span class="fc" id="L773">    					}						 </span>

    					// ** END ****** 20 ************************ 20 ************************** 20 ***************************/


    					// ** START  ****** 32 ************************ 32 ************************** 32 ***************************/
    					//@ID (/opt/features/vector_features/data/data_value_geometry_srs_id)
    					//@Test( description = &quot;See OGC 12-128r14: Requirement 32 all items&quot;, dataProvider = &quot;feature-geometry-information&quot;)

    					/*
    					 *  REQUIREMENT 32
    					 * Test Method
    					 *    3. For each row from step 1
    					 *    a. *Select the set of geometry types in use for the values in cn (geometry column)   WAS: SELECT DISTINCT ST_GeometryType(cn) FROM tn
    					 *    b. For each row actual_type_name from step a
    					 *    i. Determine if each geometry type is assignable to the actual_type_name
    					 *    ii. Fail if any are not assignable
    					 *    4. Pass if no fails
    					 *    
    					 */


    					// Guess what - we have already retrieved both the current WKB geometry type and the geometry specified for this feature type
    					// so it is just a matter of determining whether the
    					// geom_type representing the geometry_column_table type vs. the GeometryType in the current WKB record are compatible.
    					try {

    						// Verify that the actual geometry type is 'assignable' i.e. equal to or a subset of the specified geometry from the geometry table
    						// The call to IsAssignable is expecting a return of 1 if assignable, 0 if not.
    						// the variable actualGeometryType is coming from the feature WKB while the geomType is from the gpkg_geometry_columns
    						// If the value actualGeometryType is equal to or is defined a s a subtype to the geomType, this will return the value of 1

<span class="pc bpc" id="L805" title="1 of 2 branches missed.">    						if ( this.IsAssignable(geomType, actualGeometryType) == 0 ) {</span>
<span class="nc" id="L806">    							errorDetected32 ++;</span>
<span class="nc bnc" id="L807" title="All 2 branches missed.">    							if (errorDetected32 &lt; maxErrorsToReport32)</span>
<span class="nc" id="L808">    								Assert.assertTrue(false,</span>
<span class="nc" id="L809">    										ErrorMessage.format(ErrorMessageKeys.FEATURE_GEOMETRY_NOT_ASSIGNABLE_TO_SUPERTYPE,		</span>
<span class="nc" id="L810">    												rowID, thisColumnName, geomType, actualGeometryType, thisTableName));</span>
    						}

<span class="nc" id="L813">    					} catch(final Exception th)</span>
    					{
<span class="nc" id="L815">    						fail(</span>
<span class="nc" id="L816">    								ErrorMessage.format(</span>
    										ErrorMessageKeys.FEATURE_GEOMETRY_BLOB_PROCESSING_TEST_FAILURE, 
<span class="nc" id="L818">    										String.format(&quot;Failure testing requirement 32 on feature {0}&quot;, thisTableName), th.getMessage()));</span>
<span class="fc" id="L819">    					}</span>

    					// ** END  ****** 32 ************************ 32 ************************** 32 **************************



    					// ************** PARTIAL TEST for Requirement 66 here ********** 66************************66 *********************66 ***************
    					//
<span class="fc" id="L827">    					int geometryItemCount = 1;</span>
<span class="fc bfc" id="L828" title="All 2 branches covered.">        				if (actualGeometryType != geomPOINT)</span>
        				{
<span class="fc" id="L830">        					byte[] wkbGeometryCount = byteArraySubset(bytes, geometryStart + startOfGeometryType + Integer.BYTES, Integer.BYTES);</span>
<span class="fc" id="L831">        					geometryItemCount = getIntegerFromBytesWithPossibleSwap(wkbGeometryCount, swapGeometryBytes);</span>
        				}
<span class="pc bpc" id="L833" title="1 of 2 branches missed.">        				if (geometryItemCount &lt; 0) {</span>
<span class="nc" id="L834">							errorDetected66 ++;</span>
<span class="nc bnc" id="L835" title="All 2 branches missed.">							if (errorDetected66 &lt; maxErrorsToReport66)</span>
<span class="nc" id="L836">								Assert.assertTrue(false,</span>
<span class="nc" id="L837">										ErrorMessage.format(ErrorMessageKeys.FEATURE_GEOMETRY_WKB_ITEM_COUNT_ILLEGAL,		</span>
<span class="nc" id="L838">												thisTableName, rowID, thisColumnName,  actualGeometryType, geometryItemCount));        					</span>
        				}
        				// ** END  ****** PARTIAL 66 ************************ 66 ************************** 66 **************************


    					// ** START  ****** 67 ************************ 67 ************************** 67 **************************
    					/*  
    					 * REQUIREMENT 67
    					 *  C. SELECT ST_GeometryType(geometry column value) AS &lt;gtype&gt;;
    					 * D.  SELECT extension_name FROM gpkg_extensions WERE table_name
    					 *     = result_set_table_name AND  column_name = result_set_column_name AND extension_name = \'gpkg_geom_' || &lt;gtype&gt;
    					 * I.  Fail if result set is empty
    					 * II.  Log pass otherwise
    					 * 4.  Pass  if logged pass and no fails
    					 */

<span class="fc bfc" id="L854" title="All 2 branches covered.">    					if (this.hasGPKGExtensionsTable == true)</span>
    					{
    						try {
    							// Tests have shown it is possible to NOT have these in the extensions table at all. Since they are 'extensions' that would
    							// not be an error!  Therefore, first check to be sure the gpkg_geom_* extensions are present at all in the gpkg_extensions
    							// table.  If, at some time, it is determine that these are requirements and not just extensions, we can remove this
    							// first sub-test.
<span class="fc" id="L861">    							boolean testForGeomExtensions = false;</span>
<span class="pc" id="L862">    							try(final Statement statementST = this.databaseConnection.createStatement();</span>
<span class="fc" id="L863">    									final ResultSet resultSetST = statementST.executeQuery(String.format(</span>
    											&quot;SELECT extension_name FROM gpkg_extensions WHERE (extension_name LIKE \'gpkg_geom_\');&quot;)))	        	                            
    							{
<span class="pc bpc" id="L866" title="1 of 2 branches missed.">    								if (resultSetST.next() == true) {  // false if the result is empty</span>
<span class="nc" id="L867">    									testForGeomExtensions = true;</span>
    								}
<span class="pc bpc" id="L869" title="12 of 16 branches missed.">    							}</span>

    							// If we have verified the geometry extensions are present in the extensions table, proceed
<span class="pc bpc" id="L872" title="1 of 2 branches missed.">    							if (testForGeomExtensions) {</span>
<span class="nc" id="L873">    								try(final Statement statementST = this.databaseConnection.createStatement();</span>
<span class="nc" id="L874">    										final ResultSet resultSetST = statementST.executeQuery(String.format(</span>
    												&quot;SELECT extension_name FROM gpkg_extensions WHERE (table_name = \'%s\' AND column_name = \'%s\' AND extension_name = \'gpkg_geom_%s\');&quot;, 
    												thisTableName, thisColumnName, actualGeometryType)))		        	                            
    								{
<span class="nc bnc" id="L878" title="All 2 branches missed.">    									if (resultSetST.next() == false)  { // returns false if the result set is empty	    				 </span>
<span class="nc" id="L879">    										errorDetected67 ++;</span>
<span class="nc bnc" id="L880" title="All 2 branches missed.">    										if (errorDetected67 &lt; maxErrorsToReport67)</span>
<span class="nc" id="L881">    											Assert.assertTrue(false,</span>
<span class="nc" id="L882">    													ErrorMessage.format(ErrorMessageKeys.FEATURE_GEOMETRY_TYPE_NOT_PRESENT_AS_EXTENSION,</span>
<span class="nc" id="L883">    															rowID, thisColumnName, actualGeometryType, actualGeometryType, thisTableName));</span>
    									}	    				 
<span class="nc bnc" id="L885" title="All 16 branches missed.">    								}</span>
    							}
<span class="nc" id="L887">    						} catch(final Exception th)</span>
    						{
<span class="nc" id="L889">    							fail(</span>
<span class="nc" id="L890">    									ErrorMessage.format(</span>
    											ErrorMessageKeys.FEATURE_GEOMETRY_BLOB_PROCESSING_TEST_FAILURE, 
<span class="nc" id="L892">    											String.format(&quot;Failure testing requirement 67 on feature {0}&quot;, thisTableName), th.getMessage()));</span>
<span class="fc" id="L893">    						}</span>
    					}

    					// ** END  ****** 67 ************************ 67 ************************** 67 **************************

    				} // End tests of WKB Geometry requiring non empty geometry flag





    				// ** START   ****** NSG 19B ************************ NSG 19B ************************** NSG 19B **************************
    				//@Test( description = &quot;See NSG Requirement 19b: Requirement NSG 19b features portion&quot;, dataProvider = &quot;feature-geometry-information&quot;)




    				// This next set looks at the gpkg_contents as compared to the values in the feature
    				// instance geometry BLOB.  This is for NSG requirement 19 B
    				// NOTE: This test does not test profiles but we're going to keep it (commented out) for now
    				// because a requirement could be added as part of GPKG 1.3.0.
    				/*
    				try {
    					if (!envelopeVals.isEmpty()) {
    						try(final Statement statementST = this.databaseConnection.createStatement();
    								final ResultSet resultSetST = statementST.executeQuery(
    										String.format(
    							&quot;SELECT srs_id as srsContents, min_x, min_y, max_x, max_y FROM gpkg_contents WHERE (data_type = \'features\' and table_name = \'%s\' and srs_id IN (%s) );&quot;,
    							thisTableName, srs_id)))
    						{

    							while (resultSetST.next()) {
    								// Get the srs extents and save for comparison
    								final Map&lt;String, Double&gt; extentsforsrs = new HashMap&lt;&gt;();
    								extentsforsrs.put(myminx, resultSetST.getDouble(&quot;min_x&quot;));
    								extentsforsrs.put(mymaxx, resultSetST.getDouble(&quot;max_x&quot;));
    								extentsforsrs.put(myminy, resultSetST.getDouble(&quot;min_y&quot;));
    								extentsforsrs.put(mymaxy, resultSetST.getDouble(&quot;max_y&quot;));


    								// If they are null, all values will be 0 (getDouble) will put them to 0 if they are null. 
    								// Perform the test if any values are set and test only if we have anything of value here.

    								if (!checkIfValueWithinToleranceOfTargetValue(extentsforsrs.get(myminx),0.0D, 1.0e-10) ||  
    										!checkIfValueWithinToleranceOfTargetValue(extentsforsrs.get(myminy),0.0D, 1.0e-10) || 
    										!checkIfValueWithinToleranceOfTargetValue(extentsforsrs.get(mymaxx),0.0D, 1.0e-10) || 
    										!checkIfValueWithinToleranceOfTargetValue(extentsforsrs.get(mymaxy),0.0D, 1.0e-10)) {
    									final String enveloperesult = geometryEnvelopeWithinExtents(envelopeVals, extentsforsrs);
    									if (enveloperesult != &quot;&quot;) {
    										errorDetectedNSG19b ++;
    										if (errorDetectedNSG19b &lt; maxErrorsToReportNSG19b) {
    											Assert.assertTrue(false,
    													ErrorMessage.format(ErrorMessageKeys.FEATURE_GEOMETRY_ENVELOPE_OUTSIDE_BOUNDS_OF_GEOPACKAGE,
    															rowID, thisColumnName, srs_id, thisTableName, envelopeVals.get(myminx), envelopeVals.get(mymaxx),  
    															envelopeVals.get(myminy),  envelopeVals.get(mymaxy), enveloperesult ));
    										}

    									}  // end if geometryEvelopeWithinExtents == false
    								} // end if check of min max values show they are not 0
    							}
    						}
    					}
    				} catch(final Exception th)
    				{

    					fail(
    							ErrorMessage.format(
    									ErrorMessageKeys.FEATURE_GEOMETRY_BLOB_PROCESSING_TEST_FAILURE, 
    									String.format(&quot;Failure testing requirement NSG 19B on feature {0}&quot;, thisTableName), th.getMessage()));
    				}
						*/
    				// ** END   ****** NSG 19B ************************ NSG 19B ************************** NSG 19B **************************



    				// ** START   ****** 78 ************************ 78 ************************** 78 **************************
    				//@Test( description = &quot;See OGC 12-128r14: Requirement 78&quot;, dataProvider = &quot;feature-geometry-information&quot;)



    				// Tests on gpkg_extensions and rtree. We have to flip the stated test around because we are doing this per
    				// feature instance.
    				// Stated test #78 from Spec 128r14
    				//
    				// Using the rtree_FeatureTableName_GeometryColumnName
    				// 1.  Open Geometry Test Data Set GeoPackage with GeoPackage SQLite Extension
    				// 2.  For   each  Geometry Test   Data  Set   &lt;gtype_test&gt; data  table  row  for   each geometry type in  Annex G, for  an assortment of srs_ids, 
    				//      for  an assortment of coordinate values including empty geometries, without and with z and / or  m values, in both big and little endian encodings:
    				// a.  SELECT 'Fail'  FROM &lt;gtype_test&gt; WHERE ST_IsEmpty(geom.) != empty  &lt;---- note we are not checking this. This test is not going to happen if the geometry is empty
    				// b.  SELECT 'Fail'  FROM &lt;gtype_test&gt; WHERE ST_MinX(geom) != minx
    				// c.  SELECT 'Fail'  FROM &lt;gtype_test&gt; WHERE ST_MaxX(geom) != maxx 
    				// d.  SELECT 'Fail'  FROM &lt;gtype_test&gt; WHERE ST_MinY(geom) != miny 
    				// e.  SELECT 'Fail'  FROM &lt;gtype_test&gt; WHERE ST_MaxY(geom) != maxy
    				// 3.  Pass  if no 'Fail'  selected from step 2

    				// Dependent on the feature instance min and max geometry values and whether we have envelope values

    				try {

    					// If we have no envelope, we cannot perform this test
<span class="fc bfc" id="L993" title="All 2 branches covered.">    					if (!envelopeVals.isEmpty()) {</span>

<span class="fc" id="L995">    						final String rtreeTable = String.format(&quot;rtree_%s_%s&quot;,thisTableName, thisColumnName);</span>

<span class="pc" id="L997">    						try(final Statement statementST = this.databaseConnection.createStatement();</span>
<span class="fc" id="L998">    								final ResultSet resultSetST = statementST.executeQuery(String.format(&quot;SELECT minx, maxx, miny, maxy FROM \'%s\' WHERE (rowid = %s);&quot;, rtreeTable, rowID)))		        	                            </span>
    						{
<span class="fc" id="L1000">    							final Double localtolerance = 1.0e-4;        // 1.0e-5 is not good enough for most geopackages to pass!</span>

<span class="fc bfc" id="L1002" title="All 2 branches covered.">    							while(resultSetST.next() ) {</span>
<span class="fc" id="L1003">    								final Map&lt;String, Double&gt; rtreeminmaxVals = new HashMap&lt;&gt;();</span>
<span class="fc" id="L1004">    								rtreeminmaxVals.put(myminx, resultSetST.getDouble(myminx));</span>
<span class="fc" id="L1005">    								rtreeminmaxVals.put(mymaxx, resultSetST.getDouble(mymaxx));</span>
<span class="fc" id="L1006">    								rtreeminmaxVals.put(myminy, resultSetST.getDouble(myminy));</span>
<span class="fc" id="L1007">    								rtreeminmaxVals.put(mymaxy, resultSetST.getDouble(mymaxy));</span>

    								// Verify the geometry envelope falls within the rtree extents for this instance
    								// final String enveloperesult = geometryEnvelopeWithinExtents(envelopeVals, rtreeminmaxVals);   // this test would test for the envelope within the rtree, not equal to
<span class="pc bpc" id="L1011" title="1 of 2 branches missed.">    								if (!checkIfValueWithinToleranceOfTargetValue(rtreeminmaxVals.get(myminx), envelopeVals.get(myminx), localtolerance) ||</span>
<span class="pc bpc" id="L1012" title="1 of 2 branches missed.">    										!checkIfValueWithinToleranceOfTargetValue(rtreeminmaxVals.get(mymaxx), envelopeVals.get(mymaxx), localtolerance) ||</span>
<span class="pc bpc" id="L1013" title="1 of 2 branches missed.">    										!checkIfValueWithinToleranceOfTargetValue(rtreeminmaxVals.get(myminy), envelopeVals.get(myminy), localtolerance) ||</span>
<span class="pc bpc" id="L1014" title="1 of 2 branches missed.">    										!checkIfValueWithinToleranceOfTargetValue(rtreeminmaxVals.get(mymaxy), envelopeVals.get(mymaxy), localtolerance) )						 </span>
    								{
<span class="nc" id="L1016">    									errorDetected78 ++;</span>
<span class="nc bnc" id="L1017" title="All 2 branches missed.">    									if (errorDetected78 &lt; maxErrorsToReport78) {</span>
<span class="nc" id="L1018">    										Assert.assertTrue(false,</span>
<span class="nc" id="L1019">    												ErrorMessage.format(ErrorMessageKeys.FEATURE_GEOMETRY_ENVELOPE_OUTSIDE_TOLERANCE_OF_RTREE_TRIGGER_MIN_MAX,</span>
<span class="nc" id="L1020">    														rowID, thisColumnName, thisTableName, envelopeVals.get(myminx), envelopeVals.get(mymaxx),  envelopeVals.get(myminy),  envelopeVals.get(mymaxy)));</span>
    									}

    								}
<span class="fc" id="L1024">    							}</span>
<span class="pc bpc" id="L1025" title="10 of 16 branches missed.">    						}</span>
    					}
<span class="fc" id="L1027">    				} catch(final Exception th)</span>
    				{

    					//   At this time, do not report an error here. If there is no rtree table, I guess it is not worth reporting an error
    					//   ets-gpkg12 tests including the features-0.gpkg sample will fail right here.
    					//		 errorDetected78 ++;
    					//		 if (errorDetected78 &lt; maxErrorsToReport78) {
    					//			 Assert.assertTrue(false,
    					//					ErrorMessage.format(ErrorMessageKeys.FEATURE_GEOMETRY_ENVELOPE_RTREE_TABLE_MISSING_OR_IN_ERROR,
    					//							thisTableName, thisColumnName));
    					//		 }
<span class="fc" id="L1038">    				}</span>


    				// ** END   ****** 78 ************************ 78 ************************** 78 **************************

    			} // End while result set
<span class="pc bpc" id="L1044" title="12 of 16 branches missed.">    		}</span>
    	} 
<span class="nc" id="L1046">    	catch(final Exception th)</span>
    	{
<span class="nc" id="L1048">    		fail(</span>
<span class="nc" id="L1049">    				ErrorMessage.format(</span>
<span class="nc" id="L1050">    						ErrorMessageKeys.FEATURE_GEOMETRY_BLOB_PROCESSING_TEST_FAILURE, &quot;main loop&quot;, th.getMessage()));</span>
<span class="fc" id="L1051">    	}   </span>
<span class="fc" id="L1052">    }</span>

 

	/**
	 * Test case
	 * {@code /opt/features/geometry_columns/data/table_def}
	 *
	 * @see &lt;a href=&quot;_requirement-21&quot; target= &quot;_blank&quot;&gt;Vector
	 *      Features Geometry Columns Table - Requirement 21&lt;/a&gt;
	 *
	 * @throws SQLException
	 *             If an SQL query causes an error
	 */
	@Test(description = &quot;See OGC 12-128r13: Requirement 21&quot;)
	public void featureGeometryColumnsTableDef() throws SQLException {
<span class="pc" id="L1068">		try (</span>
				// 1
<span class="fc" id="L1070">				final Statement statement = this.databaseConnection.createStatement();</span>

<span class="fc" id="L1072">				final ResultSet resultSet = statement.executeQuery(&quot;PRAGMA table_info(\'gpkg_geometry_columns\');&quot;);</span>
				) {

			// 2
<span class="fc" id="L1076">			int passFlag = 0;</span>
<span class="fc" id="L1077">			final int flagMask = 0b00111111;</span>

<span class="fc bfc" id="L1079" title="All 2 branches covered.">			while (resultSet.next()) {</span>
				// 3
<span class="fc" id="L1081">				final String name = resultSet.getString(&quot;name&quot;);</span>
<span class="fc bfc" id="L1082" title="All 2 branches covered.">				if (&quot;geometry_type_name&quot;.equals(name)){</span>
<span class="fc" id="L1083">					assertTrue(&quot;TEXT&quot;.equals(resultSet.getString(&quot;type&quot;)), ErrorMessageKeys.FEATURES_GEOMETRY_COLUMNS_INVALID);</span>
<span class="pc bpc" id="L1084" title="1 of 2 branches missed.">					assertTrue(resultSet.getInt(&quot;notnull&quot;) == 1, ErrorMessageKeys.FEATURES_GEOMETRY_COLUMNS_INVALID);</span>
<span class="pc bpc" id="L1085" title="1 of 2 branches missed.">					assertTrue(resultSet.getInt(&quot;pk&quot;) == 0, ErrorMessageKeys.FEATURES_GEOMETRY_COLUMNS_INVALID);</span>
<span class="fc" id="L1086">					passFlag |= 1;</span>
<span class="fc bfc" id="L1087" title="All 2 branches covered.">				} else if (&quot;table_name&quot;.equals(name)){</span>
<span class="fc" id="L1088">					assertTrue(&quot;TEXT&quot;.equals(resultSet.getString(&quot;type&quot;)), ErrorMessageKeys.FEATURES_GEOMETRY_COLUMNS_INVALID);</span>
<span class="pc bpc" id="L1089" title="1 of 2 branches missed.">					assertTrue(resultSet.getInt(&quot;notnull&quot;) == 1, ErrorMessageKeys.FEATURES_GEOMETRY_COLUMNS_INVALID);</span>
<span class="pc bpc" id="L1090" title="1 of 2 branches missed.">					assertTrue(resultSet.getInt(&quot;pk&quot;) == 1, ErrorMessageKeys.FEATURES_GEOMETRY_COLUMNS_INVALID);</span>
<span class="fc" id="L1091">					passFlag |= (1 &lt;&lt; 1);</span>
<span class="fc bfc" id="L1092" title="All 2 branches covered.">				} else if (&quot;m&quot;.equals(name)){</span>
<span class="fc" id="L1093">					assertTrue(&quot;TINYINT&quot;.equals(resultSet.getString(&quot;type&quot;)), ErrorMessageKeys.FEATURES_GEOMETRY_COLUMNS_INVALID);</span>
<span class="pc bpc" id="L1094" title="1 of 2 branches missed.">					assertTrue(resultSet.getInt(&quot;notnull&quot;) == 1, ErrorMessageKeys.FEATURES_GEOMETRY_COLUMNS_INVALID);</span>
<span class="pc bpc" id="L1095" title="1 of 2 branches missed.">					assertTrue(resultSet.getInt(&quot;pk&quot;) == 0, ErrorMessageKeys.FEATURES_GEOMETRY_COLUMNS_INVALID);</span>
<span class="fc" id="L1096">					passFlag |= (1 &lt;&lt; 2);</span>
<span class="fc bfc" id="L1097" title="All 2 branches covered.">				} else if (&quot;z&quot;.equals(name)){</span>
<span class="fc" id="L1098">					assertTrue(&quot;TINYINT&quot;.equals(resultSet.getString(&quot;type&quot;)), ErrorMessageKeys.FEATURES_GEOMETRY_COLUMNS_INVALID);</span>
<span class="pc bpc" id="L1099" title="1 of 2 branches missed.">					assertTrue(resultSet.getInt(&quot;notnull&quot;) == 1, ErrorMessageKeys.FEATURES_GEOMETRY_COLUMNS_INVALID);</span>
<span class="pc bpc" id="L1100" title="1 of 2 branches missed.">					assertTrue(resultSet.getInt(&quot;pk&quot;) == 0, ErrorMessageKeys.FEATURES_GEOMETRY_COLUMNS_INVALID);</span>
<span class="fc" id="L1101">					passFlag |= (1 &lt;&lt; 3);</span>
<span class="fc bfc" id="L1102" title="All 2 branches covered.">				} else if (&quot;srs_id&quot;.equals(name)){</span>
<span class="fc" id="L1103">					assertTrue(&quot;INTEGER&quot;.equals(resultSet.getString(&quot;type&quot;)), ErrorMessageKeys.FEATURES_GEOMETRY_COLUMNS_INVALID);</span>
<span class="pc bpc" id="L1104" title="1 of 2 branches missed.">					assertTrue(resultSet.getInt(&quot;notnull&quot;) == 1, ErrorMessageKeys.FEATURES_GEOMETRY_COLUMNS_INVALID);</span>
<span class="pc bpc" id="L1105" title="1 of 2 branches missed.">					assertTrue(resultSet.getInt(&quot;pk&quot;) == 0, ErrorMessageKeys.FEATURES_GEOMETRY_COLUMNS_INVALID);</span>
<span class="fc" id="L1106">					passFlag |= (1 &lt;&lt; 4);</span>
<span class="pc bpc" id="L1107" title="1 of 2 branches missed.">				} else if (&quot;column_name&quot;.equals(name)){</span>
<span class="fc" id="L1108">					assertTrue(&quot;TEXT&quot;.equals(resultSet.getString(&quot;type&quot;)), ErrorMessageKeys.FEATURES_GEOMETRY_COLUMNS_INVALID);</span>
<span class="pc bpc" id="L1109" title="1 of 2 branches missed.">					assertTrue(resultSet.getInt(&quot;notnull&quot;) == 1, ErrorMessageKeys.FEATURES_GEOMETRY_COLUMNS_INVALID);</span>
<span class="pc bpc" id="L1110" title="1 of 2 branches missed.">					assertTrue(resultSet.getInt(&quot;pk&quot;) == 2, ErrorMessageKeys.FEATURES_GEOMETRY_COLUMNS_INVALID);</span>
<span class="fc" id="L1111">					passFlag |= (1 &lt;&lt; 5);</span>
				}
<span class="fc" id="L1113">			} </span>
<span class="pc bpc" id="L1114" title="1 of 2 branches missed.">			assertTrue((passFlag &amp; flagMask) == flagMask, ErrorMessageKeys.FEATURES_GEOMETRY_COLUMNS_INVALID);			</span>
<span class="pc bpc" id="L1115" title="12 of 16 branches missed.">		}</span>
<span class="fc" id="L1116">	}</span>

	/**
	 * Test case
	 * {@code /opt/features/geometry_columns/data/data_values_geometry_columns}
	 *
	 * @see &lt;a href=&quot;_requirement-22&quot; target= &quot;_blank&quot;&gt;Vector
	 *      Features Geometry Columns Table - Requirement 22&lt;/a&gt;
	 *
	 * @throws SQLException
	 *             If an SQL query causes an error
	 */
	@Test(description = &quot;See OGC 12-128r13: Requirement 22&quot;)
	public void featureGeometryColumnsDataValues() throws SQLException {
<span class="pc" id="L1130">		try (		</span>
				// 1
<span class="fc" id="L1132">				final Statement statement = this.databaseConnection.createStatement();</span>

<span class="fc" id="L1134">				final ResultSet resultSet = statement.executeQuery(&quot;SELECT table_name FROM gpkg_contents WHERE data_type = \'features\';&quot;);</span>
				) {
			// 2
<span class="pc bpc" id="L1137" title="1 of 2 branches missed.">			if (resultSet.next()){</span>
<span class="pc" id="L1138">				try (</span>
						// 3
<span class="fc" id="L1140">						final Statement statement2 = this.databaseConnection.createStatement();</span>

<span class="fc" id="L1142">						final ResultSet resultSet2 = statement2.executeQuery(&quot;SELECT table_name FROM gpkg_contents WHERE data_type = \'features\' AND table_name NOT IN (SELECT table_name FROM gpkg_geometry_columns);&quot;);</span>
						) {
<span class="pc bpc" id="L1144" title="1 of 2 branches missed.">					assertTrue(!resultSet2.next(), ErrorMessageKeys.FEATURES_GEOMETRY_COLUMNS_MISMATCH);</span>
<span class="pc bpc" id="L1145" title="12 of 16 branches missed.">				}</span>
			}			
<span class="pc bpc" id="L1147" title="12 of 16 branches missed.">		}</span>
<span class="fc" id="L1148">	}</span>

	/**
	 * Test case
	 * {@code /opt/features/geometry_columns/data/data_values_table_name} and
	 * {@code /opt/features/geometry_columns/data/data_values_srs_id}
	 *
	 * @see &lt;a href=&quot;_requirement-23&quot; target= &quot;_blank&quot;&gt;Vector
	 *      Features Geometry Columns Table - Requirement 23&lt;/a&gt;
	 * and  &lt;a href=&quot;_requirement-26&quot; target= &quot;_blank&quot;&gt;Vector
	 *      Features Geometry Columns SRS ID - Requirement 26&lt;/a&gt;
	 *
	 * @throws SQLException
	 *             If an SQL query causes an error
	 */
	@Test(description = &quot;See OGC 12-128r13: Requirement 23, 26&quot;)
	public void featureGeometryColumnsDataValuesTableName() throws SQLException {
<span class="pc" id="L1165">		try (</span>
				// 1
<span class="fc" id="L1167">				final Statement statement = this.databaseConnection.createStatement();</span>

<span class="fc" id="L1169">				final ResultSet resultSet = statement.executeQuery(&quot;PRAGMA foreign_key_list(\'gpkg_geometry_columns\');&quot;);</span>
				) {
<span class="fc" id="L1171">			boolean foundContents = false;</span>
<span class="fc" id="L1172">			boolean foundSpatialRefSys = false;</span>

			// 2
<span class="fc bfc" id="L1175" title="All 2 branches covered.">			while (resultSet.next()){</span>
				// 3
<span class="fc" id="L1177">				final String table = resultSet.getString(&quot;table&quot;);</span>
<span class="fc bfc" id="L1178" title="All 2 branches covered.">				if (&quot;gpkg_spatial_ref_sys&quot;.equals(table)){</span>
<span class="pc bpc" id="L1179" title="2 of 4 branches missed.">					if (&quot;srs_id&quot;.equals(resultSet.getString(&quot;from&quot;)) &amp;&amp; &quot;srs_id&quot;.equals(resultSet.getString(&quot;to&quot;))){</span>
<span class="fc" id="L1180">						foundSpatialRefSys = true;</span>
					}
<span class="pc bpc" id="L1182" title="1 of 2 branches missed.">				} else if (&quot;gpkg_contents&quot;.equals(table)){</span>
<span class="pc bpc" id="L1183" title="2 of 4 branches missed.">					if (&quot;table_name&quot;.equals(resultSet.getString(&quot;from&quot;)) &amp;&amp; &quot;table_name&quot;.equals(resultSet.getString(&quot;to&quot;))){</span>
<span class="fc" id="L1184">						foundContents = true;</span>
					}
				}
<span class="fc" id="L1187">			}</span>
<span class="pc bpc" id="L1188" title="2 of 4 branches missed.">			assertTrue(foundContents &amp;&amp; foundSpatialRefSys, ErrorMessageKeys.FEATURES_GEOMETRY_COLUMNS_NO_FK);</span>
<span class="pc bpc" id="L1189" title="12 of 16 branches missed.">		}</span>
<span class="fc" id="L1190">	}</span>


	
	   /**
	    * Test case
	    * {@code /opt/features/geometry_columns/data/data_values_table_name}
	    * 
	    * Verify that the table_name column values in the gpkg_geometry_columns table are valid.
	    *
	    * @see &lt;a href=&quot;http://www.geopackage.org/spec/#_requirement-23&quot; target=
	    *            &quot;_blank&quot;&gt;Data Values Table Name - Requirement 23&lt;/a&gt;
	    * @throws SQLException
	    *                If an SQL query causes an error
	    */
	    @Test( description = &quot;See OGC 12-128r14: Requirement 23&quot;)
	    public void featureGeometryColumnsDataValuesTableNameNEW() throws SQLException
	    {
	        /*
	         * Test Method
	         *    Test as per 12-128r14
	         *    1. PRAGMA foreign_key_list(gpkg_geometry_columns);
			 *    2. Fail if there is no row designating table_name as a foreign key to table_name in gpkg_contents
	         */
<span class="pc bpc" id="L1214" title="1 of 2 branches missed.">	        if(this.hasGeometryColumnsTable)</span>
	        {

<span class="fc" id="L1217">	        	final Collection&lt;String&gt; reportFKIssues = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1218">	        	int countResults = 0;</span>
<span class="pc" id="L1219">		        try ( final Statement statement  = this.databaseConnection.createStatement();</span>
<span class="fc" id="L1220">		                 final ResultSet resultSet = statement.executeQuery(&quot;PRAGMA foreign_key_list(\'gpkg_geometry_columns\');&quot;))</span>
		            {
		        		
		        		
<span class="fc bfc" id="L1224" title="All 2 branches covered.">			            while(resultSet.next())</span>
			            {
<span class="fc" id="L1226">			            	Boolean testFailedForFKItem = true;</span>
<span class="fc" id="L1227">			            	final String thisTableName = resultSet.getString(&quot;table&quot;);   // maybe not the right column?</span>
			            	// final String thisColumnFrom = resultSet.getString(&quot;from&quot;);
<span class="fc" id="L1229">			            	final String thisColumnTo = resultSet.getString(&quot;to&quot;);</span>
<span class="fc" id="L1230">			            	countResults ++;</span>
<span class="pc" id="L1231">	                    	try(final Statement preparedStatement = this.databaseConnection.createStatement();</span>
<span class="fc" id="L1232">	                                final ResultSet pragmaTableInfo   = preparedStatement.executeQuery(String.format(&quot;PRAGMA table_info(\'%s\');&quot;, thisTableName)))</span>
	                            {
	                        		
<span class="fc bfc" id="L1235" title="All 4 branches covered.">	                                while(pragmaTableInfo.next() &amp;&amp; testFailedForFKItem)</span>
	                                {
<span class="fc" id="L1237">	                                	final String columnName = pragmaTableInfo.getString(&quot;name&quot;);</span>
	                                
<span class="fc bfc" id="L1239" title="All 2 branches covered.">	                                	if (thisColumnTo.equals(columnName))</span>
	                                	{
<span class="fc" id="L1241">	                                		testFailedForFKItem = false;</span>
	                                	}
<span class="fc" id="L1243">	                                }</span>
<span class="pc bpc" id="L1244" title="12 of 16 branches missed.">	                            }</span>
	                    	// failure if EITHER no table exists that matches the specified FK, the specified FK column in the table does not exist
<span class="pc bpc" id="L1246" title="1 of 2 branches missed.">	                    	if (testFailedForFKItem) {</span>
<span class="nc" id="L1247">	                    		reportFKIssues.add(thisTableName);</span>
	                    	}

<span class="fc" id="L1250">			            	}  // end while resultSet.next()</span>
<span class="pc bpc" id="L1251" title="12 of 16 branches missed.">			            } // end try to get foreign key list</span>

		        		// Check for the possible initial failure indicating there were no foreign keys specified at all
<span class="pc bpc" id="L1254" title="1 of 2 branches missed.">		        		if (countResults == 0) {</span>
<span class="nc" id="L1255">		        			reportFKIssues.add(&quot;No foreign key specified in gpkg_geometry_columns&quot;);</span>
		        		}
<span class="fc" id="L1257">		        		final String reportOut = String.join(&quot;, &quot;, reportFKIssues);</span>
			            
<span class="pc bpc" id="L1259" title="2 of 4 branches missed.">			            Assert.assertTrue((reportFKIssues == null || reportFKIssues.isEmpty()),</span>
<span class="fc" id="L1260">			            		ErrorMessage.format(ErrorMessageKeys.FEATURE_FOREIGN_KEY_NOT_SPECIFIED_CORRECTLY,</span>
			    						reportOut));
		      } 
	        	
<span class="fc" id="L1264">	    }</span>
		
		
		
	/**
	 * Test case
	 * {@code /opt/features/geometry_columns/data/data_values_column_name}
	 *
	 * @see &lt;a href=&quot;_requirement-24&quot; target= &quot;_blank&quot;&gt;Vector
	 *      Features Geometry Columns Column - Requirement 24&lt;/a&gt;
	 *
	 * @throws SQLException
	 *             If an SQL query causes an error
	 */
	@Test(description = &quot;See OGC 12-128r13: Requirement 24&quot;)
	public void featureGeometryColumnsDataValuesColumnName() throws SQLException {
<span class="pc" id="L1280">		try (</span>
				// 1
<span class="fc" id="L1282">				final Statement statement = this.databaseConnection.createStatement();</span>

<span class="fc" id="L1284">				final ResultSet resultSet = statement.executeQuery(&quot;SELECT table_name, column_name FROM gpkg_geometry_columns;&quot;);</span>
				) {
			// 2
<span class="fc bfc" id="L1287" title="All 2 branches covered.">			while (resultSet.next()){</span>
<span class="fc" id="L1288">				final String tableName = resultSet.getString(&quot;table_name&quot;);</span>
<span class="fc" id="L1289">				final String columnName = resultSet.getString(&quot;column_name&quot;);</span>

<span class="pc" id="L1291">				try (</span>
<span class="fc" id="L1292">						final Statement statement2 = this.databaseConnection.createStatement();</span>

<span class="fc" id="L1294">						final ResultSet resultSet2 = statement2.executeQuery(String.format(&quot;PRAGMA table_info(\'%s\');&quot;, tableName));</span>
						) {
<span class="fc" id="L1296">					boolean foundMatch = false;</span>

<span class="pc bpc" id="L1298" title="1 of 2 branches missed.">					while (resultSet2.next()) {</span>
<span class="fc bfc" id="L1299" title="All 2 branches covered.">						if (resultSet2.getString(&quot;name&quot;).equals(columnName)){</span>
<span class="fc" id="L1300">							foundMatch = true;</span>
<span class="fc" id="L1301">							break;</span>
						}
					}

<span class="fc" id="L1305">					assertTrue(foundMatch, ErrorMessage.format(ErrorMessageKeys.FEATURES_GEOMETRY_COLUMNS_INVALID_COL, tableName, columnName));</span>
<span class="pc bpc" id="L1306" title="12 of 16 branches missed.">				}</span>
<span class="fc" id="L1307">			}	</span>
<span class="pc bpc" id="L1308" title="12 of 16 branches missed.">		}</span>
<span class="fc" id="L1309">	}</span>

	/**
	 * Test case
	 * {@code /opt/features/geometry_columns/data/data_values_srs_id_match}
	 *
	 * @see &lt;a href=&quot;_requirement-146&quot; target= &quot;_blank&quot;&gt;Vector
	 *      Features Geometry Columns Column - Requirement 146&lt;/a&gt;
	 *
	 * @throws SQLException
	 *             If an SQL query causes an error
	 */
	@Test(description = &quot;See OGC 12-128r13: Requirement 146&quot;)
	public void featureGeometryColumnsDataValuesSrsId() throws SQLException {
<span class="pc" id="L1323">		try (</span>
			// 1
<span class="fc" id="L1325">			final Statement statement = this.databaseConnection.createStatement();</span>

<span class="fc" id="L1327">			final ResultSet resultSet = statement.executeQuery(&quot;SELECT a.srs_id srs_id, a.table_name tn FROM gpkg_geometry_columns a, gpkg_contents b WHERE a.table_name = b.table_name and a.srs_id != b.srs_id&quot;);</span>
		) {
			// 2
<span class="pc bpc" id="L1330" title="1 of 2 branches missed.">			if (resultSet.next()){</span>
<span class="nc" id="L1331">				fail(ErrorMessage.format(ErrorMessageKeys.SRS_MISMATCH, &quot;gpkg_geometry_columns&quot;, resultSet.getInt(&quot;srs_id&quot;), resultSet.getString(&quot;tn&quot;)));</span>
			}
<span class="pc bpc" id="L1333" title="12 of 16 branches missed.">		}</span>
<span class="fc" id="L1334">	}</span>

	/**
	 * Test case
	 * {@code /opt/features/geometry_columns/data/data_values_geometry_type_name}
	 *
	 * @see &lt;a href=&quot;_requirement-25&quot; target= &quot;_blank&quot;&gt;Vector
	 *      Features Geometry Columns Geometry Type - Requirement 25&lt;/a&gt;
	 *
	 * @throws SQLException
	 *             If an SQL query causes an error
	 */
	@Test(description = &quot;See OGC 12-128r13: Requirement 25&quot;)
	public void featureGeometryColumnsDataValuesGeometryType() throws SQLException {
<span class="pc" id="L1348">		try (</span>
				// 1
<span class="fc" id="L1350">				final Statement statement = this.databaseConnection.createStatement();</span>

<span class="fc" id="L1352">				final ResultSet resultSet = statement.executeQuery(&quot;SELECT table_name, column_name, geometry_type_name FROM gpkg_geometry_columns&quot;);</span>
				) {
			// 2
<span class="fc bfc" id="L1355" title="All 2 branches covered.">			while (resultSet.next()){</span>
				// 3
<span class="fc" id="L1357">				final String geometryTypeName = resultSet.getString(&quot;geometry_type_name&quot;);</span>
<span class="fc" id="L1358">				final String tableName = resultSet.getString(&quot;table_name&quot;);</span>
<span class="fc" id="L1359">				final String columnName = resultSet.getString(&quot;column_name&quot;);</span>

<span class="fc" id="L1361">				boolean pass = false;</span>

<span class="fc bfc" id="L1363" title="All 2 branches covered.">				if (geopackageVersion.equals(GeoPackageVersion.V120)){</span>
<span class="fc" id="L1364">					pass = ALLOWED_GEOMETRY_TYPES.contains(geometryTypeName);</span>
				} else {
<span class="fc" id="L1366">					final Iterator&lt;String&gt; iterator = ALLOWED_GEOMETRY_TYPES.iterator();</span>
<span class="pc bpc" id="L1367" title="1 of 2 branches missed.">					while(iterator.hasNext()){</span>
<span class="fc bfc" id="L1368" title="All 2 branches covered.">						if (geometryTypeName.equalsIgnoreCase(iterator.next())){</span>
<span class="fc" id="L1369">							pass = true;</span>
<span class="fc" id="L1370">							break;</span>
						}
					}
				}

<span class="fc bfc" id="L1375" title="All 2 branches covered.">				if (!pass) {</span>
<span class="fc" id="L1376">					pass = isExtendedType(tableName, columnName);</span>
				}

<span class="fc" id="L1379">				assertTrue(pass, ErrorMessage.format(ErrorMessageKeys.FEATURES_GEOMETRY_COLUMNS_INVALID_GEOM, geometryTypeName, tableName));</span>
<span class="fc" id="L1380">			}</span>
<span class="pc bpc" id="L1381" title="12 of 16 branches missed.">		}</span>
<span class="fc" id="L1382">	}</span>

	/**
	 * Test case
	 * {@code /opt/features/geometry_columns/data/data_values_z}
	 *
	 * @see &lt;a href=&quot;_requirement-27&quot; target= &quot;_blank&quot;&gt;Vector
	 *      Features Geometry Columns Z - Requirement 27&lt;/a&gt;
	 *
	 * @throws SQLException
	 *             If an SQL query causes an error
	 */
	@Test(description = &quot;See OGC 12-128r13: Requirement 27&quot;)
	public void featureGeometryColumnsDataValuesZ() throws SQLException {
<span class="pc" id="L1396">		try (</span>
				// 1
<span class="fc" id="L1398">				final Statement statement = this.databaseConnection.createStatement();</span>

<span class="fc" id="L1400">				final ResultSet resultSet = statement.executeQuery(&quot;SELECT z FROM gpkg_geometry_columns&quot;);</span>
				) {
			// 2
<span class="pc bpc" id="L1403" title="1 of 2 branches missed.">			if (resultSet.next()){</span>
<span class="pc" id="L1404">				try (</span>
						// 3
<span class="fc" id="L1406">						final Statement statement2 = this.databaseConnection.createStatement();</span>

<span class="fc" id="L1408">						final ResultSet resultSet2 = statement2.executeQuery(&quot;SELECT z FROM gpkg_geometry_columns WHERE z NOT IN (0,1,2)&quot;);</span>
						) {
<span class="pc bpc" id="L1410" title="1 of 2 branches missed.">					if(resultSet2.next()){</span>
<span class="nc" id="L1411">						assertTrue(false, ErrorMessage.format(ErrorMessageKeys.FEATURES_GEOMETRY_COLUMNS_INVALID_Z, resultSet2.getInt(&quot;z&quot;)));</span>
					}
<span class="pc bpc" id="L1413" title="12 of 16 branches missed.">				}</span>
			}
<span class="pc bpc" id="L1415" title="12 of 16 branches missed.">		}</span>
<span class="fc" id="L1416">	}</span>

	/**
	 * Test case
	 * {@code /opt/features/geometry_columns/data/data_values_m}
	 *
	 * @see &lt;a href=&quot;_requirement-28&quot; target= &quot;_blank&quot;&gt;Vector
	 *      Features Geometry Columns M - Requirement 28&lt;/a&gt;
	 *
	 * @throws SQLException
	 *             If an SQL query causes an error
	 */
	@Test(description = &quot;See OGC 12-128r13: Requirement 28&quot;)
	public void featureGeometryColumnsDataValuesM() throws SQLException {
<span class="pc" id="L1430">		try (</span>
				// 1
<span class="fc" id="L1432">				final Statement statement = this.databaseConnection.createStatement();</span>

<span class="fc" id="L1434">				final ResultSet resultSet = statement.executeQuery(&quot;SELECT m FROM gpkg_geometry_columns&quot;);</span>
				) {
			// 2
<span class="pc bpc" id="L1437" title="1 of 2 branches missed.">			if (resultSet.next()){</span>
<span class="pc" id="L1438">				try (</span>
						// 3
<span class="fc" id="L1440">						final Statement statement2 = this.databaseConnection.createStatement();</span>

<span class="fc" id="L1442">						final ResultSet resultSet2 = statement2.executeQuery(&quot;SELECT m FROM gpkg_geometry_columns WHERE m NOT IN (0,1,2)&quot;);</span>
						) {
<span class="pc bpc" id="L1444" title="1 of 2 branches missed.">					if(resultSet2.next()){</span>
<span class="nc" id="L1445">						assertTrue(false, ErrorMessage.format(ErrorMessageKeys.FEATURES_GEOMETRY_COLUMNS_INVALID_M, resultSet2.getInt(&quot;m&quot;)));</span>
					}
<span class="pc bpc" id="L1447" title="12 of 16 branches missed.">				}</span>
			}
<span class="pc bpc" id="L1449" title="12 of 16 branches missed.">		}</span>
<span class="fc" id="L1450">	}</span>

	/**
	 * Test case
	 * {@code /opt/features/vector_features/data/feature_table_one_geometry_column}
	 *
	 * @see &lt;a href=&quot;_requirement-30&quot; target= &quot;_blank&quot;&gt;Vector
	 *      Features One Geometry Column - Requirement 30&lt;/a&gt;
	 *
	 * @throws SQLException
	 *             If an SQL query causes an error
	 */
	@Test(description = &quot;See OGC 12-128r13: Requirement 30&quot;)
	public void featureTableOneGeometryColumn() throws SQLException {
<span class="pc" id="L1464">		try (		</span>
				// 1
<span class="fc" id="L1466">				final Statement statement = this.databaseConnection.createStatement();</span>

<span class="fc" id="L1468">				final ResultSet resultSet = statement.executeQuery(&quot;SELECT table_name FROM gpkg_contents WHERE data_type=\'features\'&quot;);</span>
				) {
			// 2
<span class="fc bfc" id="L1471" title="All 2 branches covered.">			while (resultSet.next()){</span>
				// 3
<span class="fc" id="L1473">				final String tableName = resultSet.getString(&quot;table_name&quot;);</span>
<span class="pc" id="L1474">				try (</span>
<span class="fc" id="L1475">						final Statement statement2 = this.databaseConnection.createStatement();</span>

<span class="fc" id="L1477">						final ResultSet resultSet2 = statement2.executeQuery(String.format(&quot;SELECT count(*) FROM gpkg_geometry_columns WHERE table_name = \'%s\'&quot;, tableName));</span>
						) {
<span class="fc" id="L1479">					resultSet2.next();</span>
<span class="pc bpc" id="L1480" title="1 of 2 branches missed.">					assertTrue(resultSet2.getInt(1) == 1, ErrorMessageKeys.FEATURES_ONE_GEOMETRY_COLUMN);</span>
<span class="pc bpc" id="L1481" title="12 of 16 branches missed.">				}</span>
<span class="fc" id="L1482">			}</span>
<span class="pc bpc" id="L1483" title="12 of 16 branches missed.">		}</span>
<span class="fc" id="L1484">	}</span>

	/**
	 * Test case
	 * {@code /opt/features/vector_features/data/feature_table_geometry_column_type}
	 *
	 * @see &lt;a href=&quot;_requirement-31&quot; target= &quot;_blank&quot;&gt;Vector
	 *      Features Geometry Column Type - Requirement 31&lt;/a&gt;
	 *
	 * @throws SQLException
	 *             If an SQL query causes an error
	 */
	@Test(description = &quot;See OGC 12-128r13: Requirement 31&quot;)
	public void featureTableGeometryColumnType() throws SQLException {
		// We're just going to skip this test on older GeoPackages and hope for the best.
<span class="fc bfc" id="L1499" title="All 2 branches covered.">		if (geopackageVersion.equals(GeoPackageVersion.V120)){</span>
<span class="pc" id="L1500">			try (</span>
					// 1
<span class="fc" id="L1502">					final Statement statement = this.databaseConnection.createStatement();</span>

<span class="fc" id="L1504">					final ResultSet resultSet = statement.executeQuery(</span>
					&quot;SELECT table_name, column_name, geometry_type_name FROM gpkg_geometry_columns WHERE table_name IN (SELECT table_name FROM gpkg_contents WHERE data_type = \'features\')&quot;);
					) {
				// 2
<span class="fc bfc" id="L1508" title="All 2 branches covered.">				while (resultSet.next()){</span>
					// 2a
<span class="fc" id="L1510">					final String geometryTypeName = resultSet.getString(&quot;geometry_type_name&quot;);</span>
					// This assertion being removed as per https://github.com/opengeospatial/geopackage/issues/347
					//				assertTrue(allowedGeometryTypes.contains(geometryTypeName), ErrorMessage.format(ErrorMessageKeys.FEATURES_GEOMETRY_COLUMNS_INVALID_GEOM, geometryTypeName));

					//2b
<span class="fc" id="L1515">					final String tableName = resultSet.getString(&quot;table_name&quot;);</span>
<span class="fc" id="L1516">					final String columnName = resultSet.getString(&quot;column_name&quot;);</span>
<span class="pc" id="L1517">					try (</span>
<span class="fc" id="L1518">							final Statement statement2 = this.databaseConnection.createStatement();</span>

<span class="fc" id="L1520">							final ResultSet resultSet2 = statement2.executeQuery(String.format(&quot;PRAGMA table_info(\'%s\')&quot;, tableName));</span>
							) {
<span class="pc bpc" id="L1522" title="1 of 2 branches missed.">						while (resultSet2.next()){</span>
<span class="fc bfc" id="L1523" title="All 2 branches covered.">							if (columnName.equals(resultSet2.getString(&quot;name&quot;))) {</span>
<span class="fc" id="L1524">								assertTrue(geometryTypeName.equals(resultSet2.getString(&quot;type&quot;)), ErrorMessageKeys.FEATURES_GEOMETRY_COLUMNS_MISMATCH);</span>
<span class="fc" id="L1525">								break;</span>
							}
						}
<span class="pc bpc" id="L1528" title="12 of 16 branches missed.">					}</span>
<span class="fc" id="L1529">				}				</span>
<span class="pc bpc" id="L1530" title="12 of 16 branches missed.">			}</span>
		}
<span class="fc" id="L1532">	}</span>


	

    // *************************SUPPORTING  METHODS *****************    SUPPORTING METHODS ***********************
    
    /**
     * Returns an integer from a byte array and provides for
     * byte swap if necessary.
     *
     * @param bytesIn The integer bytes as an array; must be number of bytes in an integer
     * @param swapFlag Boolean indicator for whether the bytes are to be swapped or not
     *
     * @return Integer value of the bytes
     * @throws IllegalArgumentException if the byte array length is not equivalent to the number of bytes in an integer
     */   
    private int getIntegerFromBytesWithPossibleSwap(byte[] bytesIn, boolean swapFlag) {
<span class="fc" id="L1550">   	 int returnValue = 0;</span>
   	// Verify length of byte array is correct, throw and error on failure
<span class="pc bpc" id="L1552" title="1 of 2 branches missed.">   	 if (bytesIn.length == Integer.BYTES) {</span>
   		 // Based on endianness of this platform and the swapFlag, and our intends use of BigInteger, which assumes BigEndian data,
   		 // determine whether the bytes will be swapped or not.  Note: We could do this the old-fashioned way with shifts as an alternative.
<span class="pc bpc" id="L1555" title="2 of 8 branches missed.">			if ((!swapFlag &amp;&amp; this.NativeOrderIsBE) || (swapFlag &amp;&amp; !this.NativeOrderIsBE)) {   </span>
<span class="fc" id="L1556">				returnValue = new BigInteger(bytesIn).intValue();</span>
				} else {
<span class="fc" id="L1558">					returnValue = Integer.reverseBytes(new BigInteger(bytesIn).intValue());</span>
				}
   	 } else {
<span class="nc" id="L1561">   		 throw new IllegalArgumentException(&quot;Invalid byte array length&quot;);</span>
   	 }
<span class="fc" id="L1563">   	 return returnValue;</span>
    }

    /**
     * Returns an long integer from a byte array and provides for
     * byte swap if necessary.
     *
     * @param bytesIn The long bytes as an array of bytes; must be number of bytes in an long integer
     * @param swapFlag Boolean indicator for whether the bytes are to be swapped or not
     *
     * @return Long value of the bytes
     * @throws IllegalArgumentException if the byte array length is not equivalent to the number of bytes in a Long integer
     */          
    private long getLongFromBytesWithPossibleSwap(byte[] bytesIn, boolean swapFlag) {
<span class="fc" id="L1577">   	 long returnValue = 0;</span>
   	 // Verify length of byte array is correct, throw and error on failure
<span class="pc bpc" id="L1579" title="1 of 2 branches missed.">   	 if (bytesIn.length == Long.BYTES) {</span>
   		 // Based on endianness of this platform and the swapFlag, and our intends use of BigInteger, which assumes BigEndian data,
   		 // determine whether the bytes will be swapped or not.  Note: We could do this the with bit shifts as an alternative; may be faster.
          	 // alternative method: (long)(bytesIn[ii+0] &lt;&lt; 56 | (bytesIn[ii+1] &amp; 0xFF) &lt;&lt; 48 | (bytesIn[ii+2] &amp; 0xFF) &lt;&lt; 40 | (bytesIn[ii+3] &amp; 0xFF) &lt;&lt; 32 | (bytesIn[ii+4] &amp; 0xFF) &lt;&lt; 24 | (bytesIn[ii+5] &amp; 0xFF) &lt;&lt; 16 | (bytesIn[ii+6] &amp; 0xFF) &lt;&lt; 8 | (bytesIn[ii+7] &amp; 0xFF));
			 // alternative method: (long)(bytesIn[ii+7] &lt;&lt; 56 | (bytesIn[ii+6] &amp; 0xFF) &lt;&lt; 48 | (bytesIn[ii+5] &amp; 0xFF) &lt;&lt; 40 | (bytesIn[ii+4] &amp; 0xFF) &lt;&lt; 32 | (bytesIn[ii+3] &amp; 0xFF) &lt;&lt; 24 | (bytesIn[ii+2] &amp; 0xFF) &lt;&lt; 16 | (bytesIn[ii+1] &amp; 0xFF) &lt;&lt; 8 | (bytesIn[ii+0] &amp; 0xFF));     
<span class="pc bpc" id="L1584" title="2 of 8 branches missed.">			if ((!swapFlag &amp;&amp; this.NativeOrderIsBE) || (swapFlag &amp;&amp; !this.NativeOrderIsBE)) {</span>
<span class="fc" id="L1585">				returnValue = new BigInteger(bytesIn).longValue();</span>
				} else {
<span class="fc" id="L1587">					returnValue = Long.reverseBytes(new BigInteger(bytesIn).longValue());</span>
				}
   	 } else {
<span class="nc" id="L1590">   		 throw new IllegalArgumentException(&quot;Invalid byte array length&quot;);</span>
   	 }
<span class="fc" id="L1592">   	 return returnValue;</span>
    }

    /**
     * Returns an double from a byte array and provides for
     * byte swap if necessary. Upon detection of NaN
     *
     * @param bytesIn The integer bytes as an array; must be number of bytes in an integer
     * @param swapFlag Boolean indicator for whether the bytes are to be swapped or not
     *
     * @return Double value of the bytes
     * 
     * @throws IllegalArgumentException if the byte array length is not equivalent to the number of bytes in a Double
     * @throws IllegalArgumentException if any value is NaN
     */ 
    private double getDoubleFromBytesWithPossibleSwap(byte[] bytesIn, boolean swapFlag) {
<span class="fc" id="L1608">   	 double returnValue = 0;</span>
   	// Verify length of byte array is correct, throw and error on failure
<span class="pc bpc" id="L1610" title="1 of 2 branches missed.">   	 if (bytesIn.length == Double.BYTES) {</span>
   		 // Cannot simply convert the bytes into a double as the floating point processor may change the
   		 // bits on us during the conversion. First get the bytes into a Long and then use the LongBitsToDouble
   		 // to move the bits into a double.
<span class="fc" id="L1614">   		 long tempLong = getLongFromBytesWithPossibleSwap(bytesIn, swapFlag);</span>
   		 // If the tempLong is NaN, throw an error that the double is not valid
   		 
   		 // Need to test for NaN here as conversion to Double may change the bits. Java encodes NaN a infinity
<span class="pc bpc" id="L1618" title="1 of 2 branches missed.">   		 if (isLongRepresentationNaN(tempLong))</span>
   		 {
<span class="nc" id="L1620">   			 throw new IllegalArgumentException(&quot;NaN&quot;);</span>
   		 } 
<span class="fc" id="L1622">       	 returnValue = Double.longBitsToDouble(tempLong);</span>
<span class="fc" id="L1623">   	 } else {</span>
<span class="nc" id="L1624">   		 throw new IllegalArgumentException(&quot;Invalid byte array length&quot;);</span>
   	 }
<span class="fc" id="L1626">   	 return returnValue;</span>
    }
    
    

    /**
     * Detects a numeric representation as NaN if provided a long integer representation
     * of a double. This tests for the NaN as specified in 12-128r14 Table 6. bit layout of GeoPackageBinary flags byte  NaN
     *
     * @param inValue The long integer representation of the bits of a double
     *
     * @return Boolean true if NaN, false if not NaN
     */ 
    private boolean isLongRepresentationNaN(long inValue)
    {

<span class="pc bpc" id="L1642" title="3 of 4 branches missed.">   	 return ((this.NativeOrderIsBE &amp;&amp; (inValue == 0x7ff8000000000000L)) || </span>
<span class="pc bpc" id="L1643" title="2 of 4 branches missed.">   		(!this.NativeOrderIsBE &amp;&amp; (inValue == 0x000000000000f87fL))) ? true : false;</span>
    }
    

    /**
     * Test for Java representation of Double NaN or Infinity which may be the Java representation
     * of the NaN as specified in OGC 12-128r14 Table 6.
     *
     * @param inValue The double value that is to be tested
     *
     * @return Boolean true if NaN, false if not NaN
     */ 
    private boolean isDoubleRepresentationNaNorInfinity(Double inValue) 
    {
<span class="pc bpc" id="L1657" title="2 of 4 branches missed.">   	 return (Double.isNaN(inValue) || Double.isInfinite(inValue)) ? true : false;</span>
    }
    
    

    /**
     * Get the geometry type string given the geometry type integer from WKB.
     * of the NaN as specified in OGC 12-128r14 Table 28.
     *
     * @param geomTypeIn The integer geometry type from WKB
     *
     * @return String geometry type. If the geometry type is not found, returns &quot;UNSUPPORTED&quot;
     */ 
    

    
    private String getGeomTypeFromNum(int geomTypeIn) {
<span class="fc" id="L1674">    	String result = &quot;&quot;;</span>
<span class="pc bpc" id="L1675" title="4 of 16 branches missed.">    	switch(geomTypeIn) {</span>
    	// Table 28. Geometry Type Codes
    	case 0: case 1000: case 2000: case 3000:
<span class="nc" id="L1678">    		result = geomGEOMETRY;</span>
<span class="nc" id="L1679">    		break;</span>
    	case 1: case 1001: case 2001: case 3001:
<span class="fc" id="L1681">    		result =  geomPOINT;</span>
<span class="fc" id="L1682">    		break;</span>
    	case 2: case 1002: case 2002: case 3002:
<span class="fc" id="L1684">    		result =  geomLINESTRING;</span>
<span class="fc" id="L1685">    		break;</span>
    	case 3: case 1003: case 2003: case 3003:
<span class="fc" id="L1687">    		result =  geomPOLYGON;</span>
<span class="fc" id="L1688">    		break;</span>
    	case 4: case 1004: case 2004: case 3004:
<span class="fc" id="L1690">    		result =  geomMULTIPOINT;</span>
<span class="fc" id="L1691">    		break;</span>
    	case 5: case 1005: case 2005: case 3005:
<span class="fc" id="L1693">    		result =  geomMULTILINESTRING;</span>
<span class="fc" id="L1694">    		break;</span>
    	case 6: case 1006: case 2006: case 3006:
<span class="fc" id="L1696">    		result =  geomMULTIPOLYGON;</span>
<span class="fc" id="L1697">    		break;</span>
    	case 7: case 1007: case 2007: case 3007:
<span class="fc" id="L1699">    		result =  geomGEOMETRYCOLLECTION;</span>
<span class="fc" id="L1700">    		break;</span>
    	// Table 28. Geometry Type Codes (Extension)
    	case 8: case 1008: case 2008: case 3008:
<span class="fc" id="L1703">    		result =  geomCIRCULARSTRING;</span>
<span class="fc" id="L1704">    		break;</span>
    	case 9: case 1009: case 2009: case 3009:
<span class="fc" id="L1706">    		result =  geomCOMPOUNDCURVE;</span>
<span class="fc" id="L1707">    		break;</span>
    	case 10: case 1010: case 2010: case 3010:
<span class="fc" id="L1709">    		result =  geomCURVEPOLYGON;</span>
<span class="fc" id="L1710">    		break;</span>
    	case 11: case 1011: case 2011: case 3011:
<span class="fc" id="L1712">    		result =  geomMULTICURVE;</span>
<span class="fc" id="L1713">    		break;</span>
    	case 12: case 1012: case 2012: case 3012:
<span class="fc" id="L1715">    		result =  geomMULTISURFACE;</span>
<span class="fc" id="L1716">    		break;</span>
    	case 13: case 1013: case 2013: case 3013:
<span class="nc" id="L1718">    		result =  geomCURVE;</span>
<span class="nc" id="L1719">    		break;</span>
    	case 14: case 1014: case 2014: case 3014:
<span class="nc" id="L1721">    		result =  geomSURFACE;</span>
<span class="nc" id="L1722">    		break;</span>
    	default:
<span class="nc" id="L1724">    		result =  geomUNSUPPORTED;    // Specific value is returned to enable tests that detect this rather than look for nothing</span>
    		break;
    	}
<span class="fc" id="L1727">    	return result;</span>
    }

    
    
    /**
     * Test if the geometry is assignable. A geometry may be more specific within a
     * feature subtype than the superclass. 
     *
     * @param supertypeGeometry The geometry type expected
     * @param subtypeGeometry   the actual geometry that has been specified
     *
     * @return Integer 1 if assignable, 0 if not assignable
     */ 
    private int IsAssignable(String supertypeGeometry, String subtypeGeometry) {
<span class="fc" id="L1742">    	int returnValue = 0;</span>

    	// Verify the string input contains values
<span class="pc bpc" id="L1745" title="2 of 4 branches missed.">    	if (!supertypeGeometry.isEmpty() &amp;&amp; !subtypeGeometry.isEmpty()) {</span>
    		// Return 1 if the stings are the same or if the supertype and subtype are valid together
<span class="fc bfc" id="L1747" title="All 2 branches covered.">        	if (supertypeGeometry.equals(subtypeGeometry) || </span>
<span class="pc bpc" id="L1748" title="1 of 2 branches missed.">        		( GeometrySubtypesAllowed.containsKey(supertypeGeometry) &amp;&amp;</span>
<span class="pc bpc" id="L1749" title="1 of 2 branches missed.">        		( GeometrySubtypesAllowed.get(supertypeGeometry)).contains(subtypeGeometry)) ) </span>
        	{
<span class="fc" id="L1751">        		returnValue = 1;</span>
        	}
    	}
<span class="fc" id="L1754">    	return returnValue;</span>
    }
    

    /**
     * Return a subset byte array from a larger starting byte array
     *
     * @param bytesIn         The source byte array
     * @param startIndex      The starting index from which the subset shall begin
     * @param numberOfBytes   The number of bytes the subset shall contain
     *           
     * @return Byte[] subsetArray subset byte array
     * 
     * @throws IllegalArgumentException if the number of bytes is invalid or the start index + number of bytes desired exceeds the length of the source array
     */ 
   private byte[] byteArraySubset(byte[] bytesIn, int startIndex, int numberOfBytes )
   {
<span class="fc" id="L1771">   	byte[] subsetArray = new byte[numberOfBytes];</span>
<span class="pc bpc" id="L1772" title="1 of 2 branches missed.">   	if ((startIndex + numberOfBytes) &lt;= bytesIn.length ) {</span>
	        
<span class="fc" id="L1774">	        System.arraycopy(bytesIn, startIndex, subsetArray, 0, numberOfBytes);</span>
	        
   	} else {
<span class="nc" id="L1777">   		throw new IllegalArgumentException(</span>
<span class="nc" id="L1778">   				String.format(</span>
<span class="nc" id="L1779">   						&quot;Invalid numberOfBytes value: %d or startIndex %d. The startIndex + numberOfBytes exceed the length of the byte array.&quot;, numberOfBytes, startIndex));</span>
   	}
<span class="fc" id="L1781">   	return subsetArray;</span>
   }

   

   /**
    * Get the set of envelope double values from the byte array
    *
    * @param bytesExpected    A count of the number of bytes expected. This value must be a multiple of 8 (the size of a double)
    * @param swapFlag Boolean indicator for whether the bytes are to be swapped or not
    * @param bytesIn          The integer bytes as an array; must be number of bytes in an integer
    * @param envelopeValues   Hash map in which the envelope values will be placed
    *
    * @return boolean true if values are returned, false if all values are 0
    * 
    * @throws IllegalArgumentException if the byte array length is invalid
    * @throws IllegalArgumentException if any value is NaN
    */ 
   private boolean mygetEnvelope(int bytesExpected, boolean swapFlag, byte[] bytesIn, Map&lt;String, Double&gt; envelopeValues) {

<span class="fc" id="L1801">   	boolean allzerovalues = true;</span>
<span class="fc" id="L1802">   	int envelopeIndex = 0;</span>
   	
<span class="fc" id="L1804">   	Assert.assertTrue(envelopeValues.isEmpty(),</span>
				 &quot;Attempt to get envelope when there are already values&quot;);
   	

<span class="pc bpc" id="L1808" title="3 of 6 branches missed.">   	if (bytesExpected &gt; 0  &amp;&amp; (bytesExpected % Double.BYTES == 0)  &amp;&amp; bytesIn.length == bytesExpected) {</span>
<span class="fc bfc" id="L1809" title="All 2 branches covered.">			for (int ii = 0; ii &lt; bytesExpected; ii += Double.BYTES) {</span>
<span class="fc" id="L1810">				final byte[] envibtem = byteArraySubset(bytesIn, ii, Double.BYTES);    // 8 bytes</span>
				try {
<span class="fc" id="L1812">					final Double tempDouble = this.getDoubleFromBytesWithPossibleSwap(envibtem, swapFlag);</span>
					
<span class="pc bpc" id="L1814" title="1 of 2 branches missed.">					if (this.isDoubleRepresentationNaNorInfinity(tempDouble)) {</span>
<span class="nc" id="L1815">						throw new IllegalArgumentException(String.format(&quot;NaN value detected.&quot;));</span>
					}
					// System.out.println(String.format(&quot;Envelope item %d with value %f&quot;, ii, tempDouble));
   				 //          1 = envelope is [minx, maxx, miny, maxy] 32 bytes envelope
   				 //          2 = envelope is [minx, maxx, miny, maxy, minz, maxz] 48 bytes envelope
   				 //          3 = envelope is [minx, maxx, miny, maxy, minz, maxz, minm, maxm]  64 bytes envelope
<span class="pc bpc" id="L1821" title="3 of 9 branches missed.">					switch(envelopeIndex) {</span>
					case 0: 
<span class="fc" id="L1823">						envelopeValues.put(myminx, tempDouble);</span>
<span class="fc" id="L1824">						break;</span>
					case 1:
<span class="fc" id="L1826">						envelopeValues.put(mymaxx, tempDouble);</span>
<span class="fc" id="L1827">						break;		</span>
					case 2:
<span class="fc" id="L1829">						envelopeValues.put(myminy, tempDouble);</span>
<span class="fc" id="L1830">						break;		</span>
					case 3:
<span class="fc" id="L1832">						envelopeValues.put(mymaxy, tempDouble);</span>
<span class="fc" id="L1833">						break;		</span>
					case 4:
<span class="fc" id="L1835">						envelopeValues.put(myminz, tempDouble);</span>
<span class="fc" id="L1836">						break;		</span>
					case 5:
<span class="fc" id="L1838">						envelopeValues.put(mymaxz, tempDouble);</span>
<span class="fc" id="L1839">						break;		</span>
					case 6:
<span class="nc" id="L1841">						envelopeValues.put(myminm, tempDouble);</span>
<span class="nc" id="L1842">						break;		</span>
					case 7:
<span class="nc" id="L1844">						envelopeValues.put(mymaxm, tempDouble);</span>
						break;		
					}
					
					
					// Extra check here because if the entire envelope is all zero values, 
					//  we basically need to clear the envelope out
					// to save from later excessive processing.  This will set a flag if there
					// are ANY non-zero envelope values seen that that we do not accidentally clear
					// it.
<span class="fc bfc" id="L1854" title="All 2 branches covered.">					if (!checkIfValueWithinToleranceOfTargetValue(tempDouble ,0.0D, 1.0e-10))</span>
<span class="fc" id="L1855">						allzerovalues = false;</span>
					
					
<span class="nc" id="L1858">				} catch (IllegalArgumentException ee)   // This is supposed to catch a NaN</span>
				{
<span class="nc" id="L1860">					throw new IllegalArgumentException(ee.getMessage());</span>
<span class="fc" id="L1861">				}</span>
<span class="fc" id="L1862">				envelopeIndex++;</span>
			}
   	} else {
   		// we either got 0 bytes length or the size of the byte array is inconsistent for a set of doubles
<span class="nc" id="L1866">   		throw new IllegalArgumentException(String.format(&quot;Invalid bytesExpected value: %d. Is 0 or is not divisible by the size of a double or not the size of the byte array parameter.&quot;, bytesExpected));</span>
   	}

		// If we found the entire envelope to be all zero, clear all the elements out of it
<span class="pc bpc" id="L1870" title="1 of 2 branches missed.">   	if (allzerovalues == true) </span>
<span class="nc" id="L1871">   		envelopeValues.clear();</span>
   	
<span class="pc bpc" id="L1873" title="1 of 2 branches missed.">   	return !allzerovalues;</span>
   }

   /**
    * Compare a envelope A defined by minx, maxx, miny, maxy values 
    * against an envelope B to determine if A falls inside or is equal to envelope B
    *
    * @param envelopein  A hash map of 4 (or more with z and m) values representing an envelope
    * @param extentin    A hash map of 4 values representing the min and max extents
    *
    * @return String     Empty string, if no issue. Otherwise it reports the first issue found
    * 
    */ 
   /* This test is only used as part of the NSG 19B test, but could be reinstated later.
   private String geometryEnvelopeWithinExtents(Map&lt;String, Double&gt; envelopein, Map&lt;String, Double&gt; extentin)
   {
   	String fallswithin = &quot;&quot;;
   	if (envelopein.get(myminx) &lt; extentin.get(myminx))
   		fallswithin = &quot;Envelope minx less than extent minx&quot;;
   	else if (envelopein.get(myminx) &gt; extentin.get(mymaxx))
   		fallswithin = &quot;Envelope minx greater than extent maxx&quot;;
   	else if (envelopein.get(mymaxx) &lt; extentin.get(myminx))
   		fallswithin = &quot;Envelope maxx less than extent minx&quot;;
   	else if (envelopein.get(mymaxx) &gt; extentin.get(mymaxx))
   		fallswithin = &quot;Envelope maxx greater than extent maxx&quot;;
 
   	else if (envelopein.get(myminy) &lt; extentin.get(myminy))
   		fallswithin = &quot;Envelope miny less than extent miny&quot;;
   	else if (envelopein.get(myminy) &gt; extentin.get(mymaxy))
   		fallswithin = &quot;Envelope miny greater than extent maxy&quot;;
   	else if (envelopein.get(mymaxy) &lt; extentin.get(myminy))
   		fallswithin = &quot;Envelope maxy less than extent miny&quot;;
   	else if (envelopein.get(mymaxy) &gt; extentin.get(mymaxy))
   		fallswithin = &quot;Envelope maxy greater than extent maxy&quot;;

   	return fallswithin;
   }
	*/
   /**
    * Return the expected size of the envelope based on the envelope code
    *
    * @param envelopeCode    The byte code for the envelope
    *           
    * @return int bytesExpected Number of bytes expected to be present in this envelope
    */ 	
	private int mygetEnvelopeByteSize(byte envelopeCode) {
<span class="fc" id="L1919">		int bytesExpected = 0;</span>

		// Note, Caution! Java sign extends each byte for this test, 
		// but these all should be okay because we are dealing with a small value
<span class="pc bpc" id="L1923" title="2 of 5 branches missed.">   	switch (envelopeCode) {</span>
		case 0:
<span class="fc" id="L1925">			bytesExpected = 0;</span>
<span class="fc" id="L1926">   		break;</span>
		case 1:    // 4 values 32 bytes
<span class="fc" id="L1928">			bytesExpected = 32;</span>
<span class="fc" id="L1929">			break;</span>
		case 2: case 3:    // 48 bytes total (another 16 bytes)
<span class="fc" id="L1931">			bytesExpected = 48;</span>
<span class="fc" id="L1932">			break;</span>
		case 4:    // 64 bytes
<span class="nc" id="L1934">			bytesExpected = 64;</span>
<span class="nc" id="L1935">			break;</span>
		default:	// invalid
<span class="nc" id="L1937">			bytesExpected = 0;</span>
			break;
   	} // end switch
<span class="fc" id="L1940">		return bytesExpected;</span>
	}

   /**
    * Compares two double values to determine if the are close enough to be called equal within
    * a specified level of tolerance
    *
    * @param valueIn     The input value (double)
    * @param targetValue The target value (double)
    * @param tolerance   The tolerance value (double)
    *           
    * @return true if the value is within tolerance of the target value, false if not
    */ 	
	private boolean checkIfValueWithinToleranceOfTargetValue(double valueIn, double targetValue, double tolerance)
	{
		
<span class="fc bfc" id="L1956" title="All 2 branches covered.">		if (Math.abs(valueIn - targetValue) &gt; tolerance)</span>
<span class="fc" id="L1957">			return false;</span>
		else
<span class="fc" id="L1959">			return true;</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>